/////////////////////////////////////////////////////////////////////////////////
// File: VcsExerciseManagement.cpp
//
// Generated by : thomas askew
// Generation date : 16:00:00 23/12/2002
//
// Copyright Alenia Marconi Systems Ltd 2002

/*------------------------------------------------------------------------------
Copyright           : Copyright (c) Alenia Marconi Systems 2002,
                      Integrated Systems Division, Donibristle.

                      The copyright of this software is the property of Alenia
                      Marconi Systems Ltd.

                      The software is supplied by Alenia Marconi Systems on the 
                      express terms that it is to be treated as confidential, and 
                      that it may not be copied, used or disclosed to others for 
                      any purpose except as authorised in writing by this company.

Project Title       : UNET

CSCI                : VCS

Module Title        : VCSExerciseManagement.cpp

Classification      : Unclassified

Language            : C++ >> C#

Operating System    : .net

Design Document Ref : See Module Specification below

------------------------------------------------------------------------------
Version Control(VSS)
---------------------
$Revision: 10 $
$Date: 8/03/05 12:40 $
$Author: Gerard.magee $
$Workfile: VCSExerciseManagement.cpp $
Revision: Frank van Bokhoven, 16 januari 2018
------------------------------------------------------------------------------
Module Specification : 

UNET-MS-090 EW Trainer To TroyCommunications System Interface Specification
UNET-MS-104 Voice Communication System Communications Interface Panel MMI
UNET-MS-134 VCS Interface PDUs

------------------------------------------------------------------------------
Module Description   : 

This module handles exercise definition using class members m_tVcsGenManage (IL
sessions) and m_pVcsExManage (STT-Single and STT-Multiple exercises). It  generates 
all queued messages that are sent to the VCS which are appended to the appropriate 
exercise queue for transmission outwith this module.  It also creates and sends
some of the VCS control messages which cannot be queued.

------------------------------------------------------------------------------*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
//# include <stdafx.h>
//# include <sstream>
//# include <math.h>
// Comms Component headers
//# include "CommsComponent.h"
//# include "systemcomponent.h"

namespace SIM2UNET
{
    public class ExerciseManagement
    {
        const string A_NONE = string.Empty;
        const bool M_ERROR = false;
        const string[8] szModeStr = { "UNKNOWN", "STT-SINGLE", "STT-MULTI", "IL", "RAD ONLY", "UNKNOWN", "UNKNOWN", "UNKNOWN" };
        const char szRoleNameStr[8] = { "INSTR_", "OP_", "CON_", "STT_IL_", "RADOP_", "ESMOP_", "RAD_", "EW_" };
        const char pszLetter[2] = { "A", "B" };

        const char szSpace[] = " ";
        const char szOpenBracket[] = "[";
        const char szCloseBracketSpace[] = "] ";
        const char szCloseBracketOpenBracket[] = "][";
        const char szEndSpace[] = "END ";
        const char szUnderscore[] = "_";

        char szSingleDigit[] = "1";
        char szTemporaryTime[] = "99:99:99:999";


        // *************************************************************************************
        // Troy Systems have modified the BI_EC_STOP message to append an additional two byte field.
        // The message is:
        //  Message ID (2 bytes)
        //  Exercise ID (2 bytes)
        //  Action (2 bytes)

        // The codes for the Action field are:

        // 0 = Behave as previously.
        const int STOP_DEFAULT = 0;

        // 1 = delete the recording from the replay PC and do not send it to the archive PC.
        const int STOP_AND_DELETE_NO_ARCHIVE = 1;

        // 2 = retain the recording on the replay PC but do not send it to the archive PC.
        // (Action 2 is not exepected to the be used).
        const int STOP_AND_KEEP_NO_ARCHIVE = 2;

        // 3 = retain the recording on the replay PC and send it to the archive PC.
        // (This is the same as Action 0).
        const int STOP_AND_ARCHIVE = 3;

        // The word "retain" does not imply setting the "Keep" flag; it merely implies not deleting
        // the recording immediately.
        // *************************************************************************************


        ///////////////////////////////////////////////////////////////////////////////
        // Function   : ResetVCS
        // Description: Generates VCS Reset Message 
        ////////////////////////////////////////////////////////////////////////////////
        //##ModelId=4119F59101C4
        public long ResetVCS()
        {
            
            string newMsg;

            if (WAIT_TIMEOUT == WaitForSingleObject(m_tVcsGenManage.hQueueMutex, 2000))
                return M_ERROR;

            /* I_SC_RESET */
            if (!(newMsg = AddMessageToQueue(NO_EXERCISE, F_RESET)))
            {
                ReleaseMutex(m_tVcsGenManage.hQueueMutex);
                return M_ERROR;
            }

            newMsg->MsgHeader.sID = (ushort)I_SC_RESET;
            newMsg->MsgHeader.sReserved = 0;

            newMsg->sMsgExpectedReply = UNET_Classes.Enums.SIM_Message_IDs.A_SC_RESET;

            newMsg->MsgHeader.usLength = 0;
            newMsg->nMsgSize = sizeof(vcsHeader_t);
            m_tVcsGenManage.nMsgCnt++;

            /* Signal message ready to send */
            if (MESSAGE_IDLE == m_tVcsGenManage.eMsgStatus)
                m_tVcsGenManage.eMsgStatus = MESSAGE_READY;

            ReleaseMutex(m_tVcsGenManage.hQueueMutex);

            return M_SUCCESS;
        }


        ////////////////////////////////////////////////////////////////////////////////
        // Function   : SetIlExercise
        // Description: Configures the IL Session within VIC
        ////////////////////////////////////////////////////////////////////////////////
        //##ModelId=4119F591023C
        public void SetIlExercise(int nMasterInstructor)
        {
            int n, i, nTraineeIdx;

            /* Extract exercise configuration data from PDU message */
            strcpy(m_pVcsExManage[IL_IDX].szExerciseSpecificationName, "IL");

            /* Create unique exercise exercise name */
            strcpy(m_pVcsExManage[IL_IDX].szUniqueExerciseName, "Session"); //IL

            strcpy(m_pVcsExManage[IL_IDX].szRecordFileName, "IL_SESSION_RECORD");

            m_pVcsExManage[IL_IDX].eLoadType = (eLoadType_t)EXERCISE_NEW;
            strcpy(m_pVcsExManage[IL_IDX].szExerciseMode, szModeStr[3]);

            m_pVcsExManage[IL_IDX].dScenarioTime = 0.0;

            m_pVcsExManage[IL_IDX].sRoleCount = 0;
            m_pVcsExManage[IL_IDX].sRadioCount = 0;
            m_pVcsExManage[IL_IDX].sActorCount = 0;

            m_pVcsExManage[IL_IDX].sMasterInstPhysicalNode = nMasterInstructor + m_sTotalNumTrainees + DESK_OFFSET;

            /* Set recording parameters */
            m_pVcsExManage[IL_IDX].sShortTermRecordControl = 0;
            m_pVcsExManage[IL_IDX].sLongTermRecordControl = 0;

            /* Assign Instructors */
            for (n = 0; n < m_sTotalNumInstructors; n++)
            {
                m_pVcsExManage[IL_IDX].Roles[n].sRoleID = n + 1;
                m_pVcsExManage[IL_IDX].Roles[n].sRoleType = CSystemComponent::SPARK_INSTRUCTOR;
                m_pVcsExManage[IL_IDX].Roles[n].sLogicalNode = (m_pVcsExManage[IL_IDX].Roles[n].sRoleID == nMasterInstructor) ? 1 : 0;
                m_pVcsExManage[IL_IDX].Roles[n].sPhysicalNode = DESK_OFFSET + m_sTotalNumTrainees + m_pVcsExManage[IL_IDX].Roles[n].sRoleID;
                strcpy(m_pVcsExManage[IL_IDX].Roles[n].szPlatform, "No Pltrm");
                strcpy(m_pVcsExManage[IL_IDX].Roles[n].szAbbrPlatform, "-");
                szSingleDigit[0] = '0' + n + 1;
                strcpy(m_pVcsExManage[IL_IDX].Roles[n].szRoleName, "INSTR_0");
                strcat(m_pVcsExManage[IL_IDX].Roles[n].szRoleName, szSingleDigit);

                m_pVcsExManage[IL_IDX].Roles[n].nAssignedRadios = 0;
                m_pVcsExManage[IL_IDX].Roles[n].nAssignedActors = 0;

                m_pVcsExManage[IL_IDX].sRoleCount++;
            }

            /* Assign Trainees */
            for (; n < m_sTotalNumRoles; n++)
            {
                nTraineeIdx = n + 2 - m_sTotalNumInstructors; //offset by 1. (2,3,4 etc)

                m_pVcsExManage[IL_IDX].Roles[n].sRoleID = n + 1;
                m_pVcsExManage[IL_IDX].Roles[n].sRoleType = CSystemComponent::SPARK_TRAINEE_OPERATOR;
                m_pVcsExManage[IL_IDX].Roles[n].sLogicalNode = n + 1;
                m_pVcsExManage[IL_IDX].Roles[n].sPhysicalNode = DESK_OFFSET + m_pVcsExManage[IL_IDX].Roles[n].sLogicalNode - m_sTotalNumInstructors;
                strcpy(m_pVcsExManage[IL_IDX].Roles[n].szPlatform, "No Pltrm");
                strcpy(m_pVcsExManage[IL_IDX].Roles[n].szAbbrPlatform, "No Pltrm");
                strcpy(m_pVcsExManage[IL_IDX].Roles[n].szRoleName, "IL ");
                szSingleDigit[0] = '0' + nTraineeIdx / 2;
                strcat(m_pVcsExManage[IL_IDX].Roles[n].szRoleName, szSingleDigit);
                strcat(m_pVcsExManage[IL_IDX].Roles[n].szRoleName, pszLetter[nTraineeIdx % 2]);

                m_pVcsExManage[IL_IDX].Roles[n].nAssignedRadios = 0;
                m_pVcsExManage[IL_IDX].Roles[n].nAssignedActors = 0;

                m_pVcsExManage[IL_IDX].sRoleCount++;
            }

            /* Finish assigning logical nodes to instructors */
            for (n = 0, i = 2; n < m_sTotalNumInstructors; n++)
            {
                if (!m_pVcsExManage[IL_IDX].Roles[n].sLogicalNode)
                    m_pVcsExManage[IL_IDX].Roles[n].sLogicalNode = i++;
            }

            /* Exercise specification ok */
            m_pVcsExManage[IL_IDX].eED_State = ED_SPECIFIED;

            return;
        }


        //        ////////////////////////////////////////////////////////////////////////////////
        //        // Function   : SetSttExercise
        //        // Description: Configures an STT exercise within VIC
        //        ////////////////////////////////////////////////////////////////////////////////
        //        //##ModelId=4119F5910282
        //        public bool SetSttExercise(msgVCSCommunicationSTTConfirmation_t pED)
        //        {
        //            int VIC_ExNo, nCurrentLogicalNode;
        //            int RoleIdx;
        //            short sCounter;
        //            bool bMasterInstructorDefined = false;
        //            bool bRadOrEwOnlyExercise = false;
        //            short sNodeID;
        //            int n = 0;
        //            char szTemp[20] = ' ';
        //            char pcTemp;
        //            void pvTemp;

        //            VIC_ExNo = pED->nAMSExerciseID; //Exercises are defined 1 to 8

        //            /* STT Exercise */

        //            /* Construct STT Exercise configuration name (8 char name plus 2 digit exercise number unique exercise name) */
        //            AppendIntStr(szTemp, VIC_ExNo, Pad_2);
        //            memset(m_pVcsExManage[VIC_ExNo].szExerciseSpecificationName, 0, sizeof(m_pVcsExManage[VIC_ExNo].szExerciseSpecificationName));

        //            pvTemp = memchr((void)pED->szUniqueExerciseName, '.', 9);

        //            if (pvTemp)
        //            {   /* Scenario name <= 8 chars */
        //                n = (char*)pvTemp - pED->szUniqueExerciseName;

        //                memcpy((void)&m_pVcsExManage[VIC_ExNo].szExerciseSpecificationName,
        //                                (void*)pED->szUniqueExerciseName,
        //                                n);

        //                memset((void)&m_pVcsExManage[VIC_ExNo].szExerciseSpecificationName[n],
        //                                ' ',
        //                                8 - n);
        //            }
        //            else
        //            {   /* Scenario name > 8 chars */
        //                memcpy((void)&m_pVcsExManage[VIC_ExNo].szExerciseSpecificationName,
        //                                (void)pED->szUniqueExerciseName,
        //                                8);
        //            }


        //            memcpy((void*)&m_pVcsExManage[VIC_ExNo].szExerciseSpecificationName[8],
        //                            (void*)szTemp,
        //                            3);

        //            /* Create unique exercise name - 2 digit exercise number */
        //            strcpy(m_pVcsExManage[VIC_ExNo].szUniqueExerciseName, szTemp);

        //            /* Set recording parameters */
        //            if (strlen(pED->szRecordFileName))
        //            {   /* Recording requested */
        //                m_pVcsExManage[VIC_ExNo].sShortTermRecordControl = 1;
        //                m_pVcsExManage[VIC_ExNo].sLongTermRecordControl = 1;

        //                /* Get record filename and adjust if necessary */
        //                memcpy((void*)m_pVcsExManage[VIC_ExNo].szRecordFileName,
        //                                (void*)pED->szRecordFileName,
        //                                sizeof(m_pVcsExManage[VIC_ExNo].szRecordFileName));

        //                std::string strLogFile(m_pVcsExManage[VIC_ExNo].szLogFileName);

        //                CTime theTime(CTime::GetCurrentTime());
        //                GetPrivateProfileString("Recording",
        //                                                                "VcsIndex",
        //                                                                theTime.Format("%d%m%Y%H%M%S"),
        //                                                                m_pVcsExManage[VIC_ExNo].szRecordFileIndex,
        //                                                                sizeof(m_pVcsExManage[VIC_ExNo].szRecordFileIndex), 
        //														strLogFile.c_str() );
        //            }
        //            else
        //            {   /* No recording required */
        //                m_pVcsExManage[VIC_ExNo].sShortTermRecordControl = 0;
        //                m_pVcsExManage[VIC_ExNo].sLongTermRecordControl = 0;
        //            }
        //            sprintf(m_szTrace, "ShortTermRecordControl %d RecordFile file '%s' \n", m_pVcsExManage[VIC_ExNo].sShortTermRecordControl, m_pVcsExManage[VIC_ExNo].szRecordFileName);
        //            Console.WriteLine("");


        //            /* Get scenario details */
        //            m_pVcsExManage[VIC_ExNo].eLoadType = (eLoadType_t)pED->nExerciseMode;
        //            strcpy(m_pVcsExManage[VIC_ExNo].szExerciseMode, szModeStr[pED->nExerciseType]);

        //            m_pVcsExManage[VIC_ExNo].dScenarioTime = pED->dScenarioTime;
        //            m_pVcsExManage[VIC_ExNo].dExerciseTime = pED->dExerciseTime;

        //            m_pVcsExManage[VIC_ExNo].sRoleCount = 0; //incremented when instructor & trainee roles added
        //            m_pVcsExManage[VIC_ExNo].sActorCount = (short)pED->nActorCount;
        //            m_pVcsExManage[VIC_ExNo].sRadioCount = (short)pED->nRadioCount;

        //            /* Radios */
        //            for (RoleIdx = 0; RoleIdx < m_pVcsExManage[VIC_ExNo].sRadioCount; ++RoleIdx)
        //            {
        //             // todo: terugzetten  memcpy((void)m_pVcsExManage[VIC_ExNo].Radio[RoleIdx].szFrequency,
        //             //                   (void*)pED->RadioData[RoleIdx].szFrequency,
        //              //                  sizeof(m_pVcsExManage[VIC_ExNo].Radio[RoleIdx].szFrequency));

        //           //todo: terugzetten memcpy((void)m_pVcsExManage[VIC_ExNo].Radio[RoleIdx].szStation,
        //           //                 (void)pED->RadioData[RoleIdx].szStation,
        //           //                 sizeof(pED->RadioData[RoleIdx].szStation));

        //         //todo: terugzetten   m_pVcsExManage[VIC_ExNo].Radio[RoleIdx].sType = (short)pED->RadioData[RoleIdx].nType;
        //         //   m_pVcsExManage[VIC_ExNo].Radio[RoleIdx].sKeyNumber = (short)pED->RadioData[RoleIdx].nKeyNumber;
        //        }

        //	/* Actor(s) */
        //	for (RoleIdx=0; RoleIdx<pED->nActorCount; RoleIdx++)
        //	{		

        //        memset(m_pVcsExManage[VIC_ExNo].Actor[RoleIdx].szPlatform, 0, sizeof(m_pVcsExManage[VIC_ExNo].Roles[RoleIdx].szPlatform));

        //        memset(m_pVcsExManage[VIC_ExNo].Actor[RoleIdx].szRoleName, 0, sizeof(m_pVcsExManage[VIC_ExNo].Roles[RoleIdx].szRoleName));


        //        memcpy(	(void) m_pVcsExManage[VIC_ExNo].Actor[RoleIdx].szPlatform, 
        //						(void) pED->ActorData[RoleIdx].szPlatform, 
        //						sizeof(m_pVcsExManage[VIC_ExNo].Actor[RoleIdx].szPlatform));		


        //        memcpy(	(void) m_pVcsExManage[VIC_ExNo].Actor[RoleIdx].szRoleName, 
        //						(void) pED->ActorData[RoleIdx].szRoleName, 
        //						sizeof(m_pVcsExManage[VIC_ExNo].Actor[RoleIdx].szRoleName));

        //		m_pVcsExManage[VIC_ExNo].Actor[RoleIdx].sKeyNumber = (short) pED->ActorData[RoleIdx].nKeyNumber;
        //	}

        ///* Roles - Instructor(s) and Trainee(s)   */
        //m_pVcsExManage[VIC_ExNo].bIndividualTraining = false;
        //	sCounter = 1;
        //	m_pVcsExManage[VIC_ExNo].sRoleCount = pED->nNodeCount;


        //	/* Handling for SEWT Radar Only and EW Only Exercises */
        //	for (RoleIdx=0 ; RoleIdx<pED->nNodeCount; RoleIdx++)
        //	{
        //		if ((eROLE_MODE_RAD == pED->NodeData[RoleIdx].nOperatingMode) || 
        //				(eROLE_MODE_EW == pED->NodeData[RoleIdx].nOperatingMode))
        //		{
        //			bRadOrEwOnlyExercise = true;
        //			m_pVcsExManage[VIC_ExNo].bIndividualTraining = true;
        //		}
        //	}

        //	for (RoleIdx=0 ; RoleIdx<pED->nNodeCount; RoleIdx++)
        //	{						
        //		m_pVcsExManage[VIC_ExNo].Roles[RoleIdx].sRoleID = sCounter++;
        //		m_pVcsExManage[VIC_ExNo].Roles[RoleIdx].sRoleType = (short) pED->NodeData[RoleIdx].nRoleType;


        //        memcpy(	(void*) m_pVcsExManage[VIC_ExNo].Roles[RoleIdx].szPlatform, 
        //						(void*) pED->NodeData[RoleIdx].szPlatform,
        //						sizeof( pED->NodeData[RoleIdx].szPlatform));


        //		/* Cope with long platform names */
        //		if (strlen(pED->NodeData[RoleIdx].szPlatform) <= sizeof(m_pVcsExManage[VIC_ExNo].Roles[RoleIdx].szAbbrPlatform))
        //		{

        //            memcpy(	(void*) m_pVcsExManage[VIC_ExNo].Roles[RoleIdx].szAbbrPlatform,
        //							(void*) pED->NodeData[RoleIdx].szPlatform, 
        //							sizeof(m_pVcsExManage[VIC_ExNo].Roles[RoleIdx].szAbbrPlatform));
        //		}
        //		else
        //		{
        //			n = sizeof(m_pVcsExManage[VIC_ExNo].Roles[RoleIdx].szAbbrPlatform) - 2;


        //            memcpy(	(void*) m_pVcsExManage[VIC_ExNo].Roles[RoleIdx].szAbbrPlatform,
        //							(void*) pED->NodeData[RoleIdx].szPlatform, 
        //							n);


        //            memcpy(	(void*) &m_pVcsExManage[VIC_ExNo].Roles[RoleIdx].szAbbrPlatform[n],
        //							(void*) &pED->NodeData[RoleIdx].szPlatform[strlen(m_pVcsExManage[VIC_ExNo].Roles[RoleIdx].szPlatform) - 2], 
        //							2);
        //		}

        //		/* Convert platform characters to lower case (excluding first char)*/
        //		pcTemp = &m_pVcsExManage[VIC_ExNo].Roles[RoleIdx].szAbbrPlatform[0];
        //		n = 0;
        //		while ( pcTemp++ && (n++ < sizeof(m_pVcsExManage[VIC_ExNo].Roles[RoleIdx].szAbbrPlatform)))

        //             pcTemp = tolower(*pcTemp);

        //m_pVcsExManage[VIC_ExNo].Roles[RoleIdx].nVehicleID = pED->NodeData[RoleIdx].nAssignedVehicleID;

        //		if (CSystemComponent::SPARK_INSTRUCTOR == pED->NodeData[RoleIdx].nRoleType)
        //		{ /* Instructor */
        //			m_pVcsExManage[VIC_ExNo].Roles[RoleIdx].nOperatingMode = eROLE_MODE_INST;

        //            strcpy(m_pVcsExManage[VIC_ExNo].Roles[RoleIdx].szRoleName, szRoleNameStr[0]);

        //            AppendIntStr(m_pVcsExManage[VIC_ExNo].Roles[RoleIdx].szRoleName, pED->NodeData[RoleIdx].nPhysicalNode , Pad_1);
        ///* Instructors get all actors and all radios */
        //m_pVcsExManage[VIC_ExNo].Roles[RoleIdx].nAssignedActors = (int) (pow(2.0, (double)m_pVcsExManage[VIC_ExNo].sActorCount)) - 1;
        //			m_pVcsExManage[VIC_ExNo].Roles[RoleIdx].nAssignedRadios = (int) (pow(2.0, (double)m_pVcsExManage[VIC_ExNo].sRadioCount)) - 1;
        //		}
        //		else if (CSystemComponent::SPARK_TRAINEE_OPERATOR == pED->NodeData[RoleIdx].nRoleType)
        //		{ /* Trainee */
        //			if ((pED->NodeData[RoleIdx].nOperatingMode == eROLE_MODE_INST) || ((pED->NodeData[RoleIdx].nOperatingMode)>eROLE_MODE_EW))
        //			{

        //                SendLoggerMessage(T_AMS_EXM, VIC_ExNo, "Unknown operating mode received for trainee");
        //				return M_ERROR;
        //			}

        //			m_pVcsExManage[VIC_ExNo].Roles[RoleIdx].nOperatingMode = pED->NodeData[RoleIdx].nOperatingMode;

        //            strcpy(m_pVcsExManage[VIC_ExNo].Roles[RoleIdx].szRoleName, szRoleNameStr[pED->NodeData[RoleIdx].nOperatingMode]);

        //            AppendIntStr(m_pVcsExManage[VIC_ExNo].Roles[RoleIdx].szRoleName, (pED->NodeData[RoleIdx].nPhysicalNode + 1)/2 , Pad_1);

        //			if (bRadOrEwOnlyExercise)

        //                strcat(m_pVcsExManage[VIC_ExNo].Roles[RoleIdx].szRoleName, pszLetter[(pED->NodeData[RoleIdx].nPhysicalNode + 1) % 2]);

        ///* Trainees get selected actors and all radios */
        //m_pVcsExManage[VIC_ExNo].Roles[RoleIdx].nAssignedActors = pED->NodeData[RoleIdx].nAssignedActors;
        //			m_pVcsExManage[VIC_ExNo].Roles[RoleIdx].nAssignedRadios = pED->NodeData[RoleIdx].nAssignedRadios;
        //		}
        //		else
        //			return M_ERROR;

        //		m_pVcsExManage[VIC_ExNo].Roles[RoleIdx].sSide = pED->NodeData[RoleIdx].sSide;

        //		/* Check that not more than one trainee if in individual training mode */
        //	//	if ((m_pVcsExManage[VIC_ExNo].bIndividualTraining) && (m_pVcsExManage[VIC_ExNo].sRoleCount != m_sTotalNumInstructors + 1))
        //	//		return M_ERROR;	

        //		/* Check physical desk assignment */
        //		sNodeID = (short) pED->NodeData[RoleIdx].nPhysicalNode;
        //		sNodeID += (pED->NodeData[RoleIdx].nRoleType == CSystemComponent::SPARK_INSTRUCTOR) ? m_sTotalNumTrainees : 0;

        //		if (bRadOrEwOnlyExercise)
        //		{
        //			if (CSystemComponent::SPARK_INSTRUCTOR == m_pVcsExManage[VIC_ExNo].Roles[RoleIdx].sRoleType)
        //			{
        //				if ((sNodeID<m_sTotalNumInstructors) || (sNodeID > m_sTotalNumNodes))
        //					return M_ERROR;	
        //			}
        //			else
        //			{
        //				if ((sNodeID< 1) || (sNodeID > m_sTotalNumTrainees))
        //					return M_ERROR;
        //			}
        //		}
        //		else
        //		{
        //			if (CSystemComponent::SPARK_INSTRUCTOR == m_pVcsExManage[VIC_ExNo].Roles[RoleIdx].sRoleType)
        //			{
        //				if ((sNodeID<m_sTotalNumInstructors) || (sNodeID > m_sTotalNumNodes))
        //					return M_ERROR;	
        //			}
        //			else
        //			{
        //				if ((sNodeID< 1) || (sNodeID > m_sTotalNumTrainees))
        //					return M_ERROR;
        //			}
        //		}

        //		sNodeID += DESK_OFFSET;

        //		m_pVcsExManage[VIC_ExNo].Roles[RoleIdx].sPhysicalNode = sNodeID;


        //		if (pED->NodeData[RoleIdx].bMasterInstructor)
        //		{
        //			m_pVcsExManage[VIC_ExNo].Roles[RoleIdx].sLogicalNode = 1;
        //			m_pVcsExManage[VIC_ExNo].sMasterInstPhysicalNode = m_pVcsExManage[VIC_ExNo].Roles[RoleIdx].sPhysicalNode;
        //			bMasterInstructorDefined = true;
        //		}
        //	}

        //	/* Assign (remaining) logical nodes for instructors & trainees		*/
        //	/* All actor roles assigned to master instructor (logical node 1) */
        //	nCurrentLogicalNode = bMasterInstructorDefined? 1 : 0;

        //	for (RoleIdx=0; RoleIdx<m_pVcsExManage[VIC_ExNo].sRoleCount; RoleIdx++)
        //	{		
        //		if (CSystemComponent::SPARK_INSTRUCTOR == m_pVcsExManage[VIC_ExNo].Roles[RoleIdx].sRoleType) 
        //		{
        //			if (!m_pVcsExManage[VIC_ExNo].Roles[RoleIdx].sLogicalNode)
        //				m_pVcsExManage[VIC_ExNo].Roles[RoleIdx].sLogicalNode = ++nCurrentLogicalNode;
        //			/* Check if had to auto-assign the  master instructor */
        //			if (1 == m_pVcsExManage[VIC_ExNo].Roles[RoleIdx].sLogicalNode)
        //				m_pVcsExManage[VIC_ExNo].sMasterInstPhysicalNode = m_pVcsExManage[VIC_ExNo].Roles[RoleIdx].sPhysicalNode;
        //		}
        //	}

        //	for (RoleIdx=0; RoleIdx<m_pVcsExManage[VIC_ExNo].sRoleCount; RoleIdx++)
        //	{		
        //		if (m_pVcsExManage[VIC_ExNo].Roles[RoleIdx].sRoleType == CSystemComponent::SPARK_TRAINEE_OPERATOR)
        //			m_pVcsExManage[VIC_ExNo].Roles[RoleIdx].sLogicalNode = ++nCurrentLogicalNode;
        //	}

        //	/* Exercise specification ok */
        //	m_pVcsExManage[VIC_ExNo].eED_State = ED_SPECIFIED;

        //	return M_SUCCESS;
        //}

        ////////////////////////////////////////////////////////////////////////////////
        // Function   : SetTestExercise
        // Description: Configures a test exercise within VIC which can be used for basic
        //							communication checks between nodes.  Invoked by switch _VCS_TEST							 
        ////////////////////////////////////////////////////////////////////////////////
        //##ModelId=4119F59102BE
        public void SetTestExercise(int TEST_ExNo)
        {
            int n, nTraineeIdx;

            strcpy(m_pVcsExManage[TEST_ExNo].szExerciseSpecificationName, "TEST_SESSION");
            strcpy(m_pVcsExManage[TEST_ExNo].szUniqueExerciseName, "CTEST");

            strcpy(m_pVcsExManage[TEST_ExNo].szRecordFileName, "TEST_RECORD");

            m_pVcsExManage[TEST_ExNo].eLoadType = (eLoadType_t)EXERCISE_NEW;
            strcpy(m_pVcsExManage[TEST_ExNo].szExerciseMode, szModeStr[0]);

            m_pVcsExManage[TEST_ExNo].dScenarioTime = 0.0;

            m_pVcsExManage[TEST_ExNo].sRoleCount = m_sTotalNumInstructors + m_sTotalNumTrainees;
            m_pVcsExManage[TEST_ExNo].sRadioCount = 2;
            m_pVcsExManage[TEST_ExNo].sActorCount = m_sTotalNumInstructors;

            m_pVcsExManage[TEST_ExNo].sMasterInstPhysicalNode = 1;

            /* Assign Instructors */
            for (n = 0; n < m_sTotalNumInstructors; n++)
            {
                m_pVcsExManage[TEST_ExNo].Roles[n].sRoleID = n + 1;
                m_pVcsExManage[TEST_ExNo].Roles[n].sRoleType = CSystemComponent::SPARK_INSTRUCTOR;
                m_pVcsExManage[TEST_ExNo].Roles[n].sLogicalNode = n + 1;
                m_pVcsExManage[TEST_ExNo].Roles[n].sPhysicalNode = DESK_OFFSET + m_sTotalNumTrainees + m_pVcsExManage[TEST_ExNo].Roles[n].sRoleID;
                strcpy(m_pVcsExManage[TEST_ExNo].Roles[n].szPlatform, "Test Platform");
                strcpy(m_pVcsExManage[TEST_ExNo].Roles[n].szAbbrPlatform, "-");
                szSingleDigit[0] = '0' + n + 1;
                strcpy(m_pVcsExManage[TEST_ExNo].Roles[n].szRoleName, "INSTR_0");
                strcat(m_pVcsExManage[TEST_ExNo].Roles[n].szRoleName, szSingleDigit);

                m_pVcsExManage[TEST_ExNo].Roles[n].nAssignedRadios = (int)(pow(2.0, (double)m_pVcsExManage[TEST_ExNo].sRadioCount)) - 1;
                m_pVcsExManage[TEST_ExNo].Roles[n].nAssignedActors = (int)(pow(2.0, (double)m_pVcsExManage[TEST_ExNo].sActorCount)) - 1;
            }

            /* Assign Trainees */
            for (; n < m_sTotalNumInstructors + m_sTotalNumTrainees; n++)
            {
                nTraineeIdx = n - m_sTotalNumInstructors + 2;

                m_pVcsExManage[TEST_ExNo].Roles[n].sRoleID = n + 1;
                m_pVcsExManage[TEST_ExNo].Roles[n].sRoleType = CSystemComponent::SPARK_TRAINEE_OPERATOR;
                m_pVcsExManage[TEST_ExNo].Roles[n].sLogicalNode = n + 1;
                m_pVcsExManage[TEST_ExNo].Roles[n].sPhysicalNode = DESK_OFFSET + m_pVcsExManage[TEST_ExNo].Roles[n].sLogicalNode - m_sTotalNumInstructors;
                strcpy(m_pVcsExManage[TEST_ExNo].Roles[n].szPlatform, "PLATFORM ");
                AppendIntStr(m_pVcsExManage[TEST_ExNo].Roles[n].szPlatform, (nTraineeIdx / 2), Pad_1);
                strcpy(m_pVcsExManage[TEST_ExNo].Roles[n].szAbbrPlatform, "PLFRM ");
                AppendIntStr(m_pVcsExManage[TEST_ExNo].Roles[n].szAbbrPlatform, (nTraineeIdx / 2), Pad_1);
                strcpy(m_pVcsExManage[TEST_ExNo].Roles[n].szRoleName, szRoleNameStr[(nTraineeIdx % 2) + 1]);
                AppendIntStr(m_pVcsExManage[TEST_ExNo].Roles[n].szRoleName, nTraineeIdx / 2, Pad_1);
                m_pVcsExManage[TEST_ExNo].Roles[n].nAssignedRadios = 0x3;
                m_pVcsExManage[TEST_ExNo].Roles[n].nAssignedActors = 0xf;
            }

            /* Assign Debrief */
            if (n == m_sTotalNumNodes - 1)
            {
                nTraineeIdx = n - m_sTotalNumInstructors + 2;

                m_pVcsExManage[TEST_ExNo].Roles[n].sRoleID = n + 1;
                m_pVcsExManage[TEST_ExNo].Roles[n].sRoleType = CSystemComponent::SPARK_TRAINEE_OPERATOR;
                m_pVcsExManage[TEST_ExNo].Roles[n].sLogicalNode = n + 1;
                m_pVcsExManage[TEST_ExNo].Roles[n].sPhysicalNode = DESK_OFFSET + m_sTotalNumNodes;
                strcpy(m_pVcsExManage[TEST_ExNo].Roles[n].szPlatform, "No Pltrm");
                strcpy(m_pVcsExManage[TEST_ExNo].Roles[n].szAbbrPlatform, "No Pltrm");
                strcpy(m_pVcsExManage[TEST_ExNo].Roles[n].szRoleName, "Debrief");
                m_pVcsExManage[TEST_ExNo].Roles[n].nAssignedRadios = 0x3;
                m_pVcsExManage[TEST_ExNo].Roles[n].nAssignedActors = 0x0;

                m_pVcsExManage[TEST_ExNo].sRoleCount += 1;
            }

            /* Radios */
            strcpy(m_pVcsExManage[TEST_ExNo].Radio[0].szFrequency, "RADIO");
            strcpy(m_pVcsExManage[TEST_ExNo].Radio[0].szStation, "HF");
            m_pVcsExManage[TEST_ExNo].Radio[0].sType = 0;
            m_pVcsExManage[TEST_ExNo].Radio[0].sKeyNumber = 3;

            strcpy(m_pVcsExManage[TEST_ExNo].Radio[1].szFrequency, "RADIO");
            strcpy(m_pVcsExManage[TEST_ExNo].Radio[1].szStation, "UHF");
            m_pVcsExManage[TEST_ExNo].Radio[1].sType = 1;
            m_pVcsExManage[TEST_ExNo].Radio[1].sKeyNumber = 8;


            /* Actor(s) */
            for (n = 0; n < m_sTotalNumInstructors; n++)
            {
                strcpy(m_pVcsExManage[TEST_ExNo].Actor[n].szPlatform, "TEST");
                strcpy(m_pVcsExManage[TEST_ExNo].Actor[n].szRoleName, "Actor_");
                szSingleDigit[0] = '0' + n + 1;
                strcat(m_pVcsExManage[TEST_ExNo].Actor[n].szRoleName, szSingleDigit);

                m_pVcsExManage[TEST_ExNo].Actor[n].sKeyNumber = 5 * n + 3;
            }

            /* Exercise specification ok */
            m_pVcsExManage[TEST_ExNo].eED_State = ED_SPECIFIED;

            return;
        }

        //////////////////////////////////////////////////////////////////////////////////
        //// Function   : DefineVcsExercise
        //// Description: Creates messages for VCS which define an exercise (or IL Session) and 
        ////							the associated instructor/actor roles
        //////////////////////////////////////////////////////////////////////////////////
        ////##ModelId=4119F59102F0
        //public bool DefineVcsExercise(int VIC_ExNo)
        //{
        //    QueuedMsg_t newMsg;

        //    char szPointDAAddress[] = "ADDR [500000][1] ";
        //    char szCabinDAAddress[] = "ADDR [1111][1] ";
        //    char szRadioType[] = { "HF", "UHF" };
        //    char szTemp[25];
        //    char pcData;


        //    int i, nRoleID, nTens, nUnits, nDesk;

        //    if (WAIT_TIMEOUT == WaitForSingleObject(m_pVcsExManage[VIC_ExNo].hQueueMutex, 2000))
        //        return M_ERROR;

        //    /* I_ES_START */
        //    if (!(newMsg = AddMessageToQueue(VIC_ExNo, F_LOAD)))
        //    {
        //        ReleaseMutex(m_pVcsExManage[VIC_ExNo].hQueueMutex);
        //        return M_ERROR;
        //    }

        //    newMsg->MsgHeader.sID = (ushort)I_ES_START; //htons((ushort) I_ES_START) doesn't work?
        //    newMsg->MsgHeader.sReserved = 0;

        //    newMsg->sMsgExpectedReply = A_ES_START;

        //    memcpy((void)newMsg->MsgData,
        //                    (void)m_pVcsExManage[VIC_ExNo].szExerciseSpecificationName,
        //                    sizeof(m_pVcsExManage[VIC_ExNo].szExerciseSpecificationName));

        //    newMsg->MsgHeader.usLength = sizeof(m_pVcsExManage[VIC_ExNo].szExerciseSpecificationName);
        //    newMsg->nMsgSize = newMsg->MsgHeader.usLength + sizeof(vcsHeader_t);
        //    m_pVcsExManage[VIC_ExNo].nMsgCnt++;

        //    /* I_ES_CONFIG */
        //    if (!(newMsg = AddMessageToQueue(VIC_ExNo, F_LOAD)))
        //    {
        //        ReleaseMutex(m_pVcsExManage[VIC_ExNo].hQueueMutex);
        //        return M_ERROR;
        //    }

        //    /* Ensure null termination of data string when concatinating fixed length character arrays */
        //    memset((void)newMsg->MsgData, 0, sizeof(newMsg->MsgData));

        //    newMsg->MsgHeader.sID = (USHORT)I_ES_CONFIG;
        //    newMsg->MsgHeader.sReserved = 0;

        //    newMsg->sMsgExpectedReply = A_ES_CONFIG;

        //    if (IL_IDX == VIC_ExNo)
        //        strcpy(newMsg->MsgData, "EXERCISE_TYPE [IL Pages] ");
        //    else
        //        strcpy(newMsg->MsgData, "EXERCISE_TYPE [STT Pages] ");

        //    strcat(newMsg->MsgData, "EXERCISE_MODE [");
        //    strcat(newMsg->MsgData, m_pVcsExManage[VIC_ExNo].szExerciseMode);
        //    strcat(newMsg->MsgData, szCloseBracketSpace);

        //    strcat(newMsg->MsgData, "ROLES ");
        //    for (nRoleID = 0; nRoleID < m_pVcsExManage[VIC_ExNo].sRoleCount; ++nRoleID)
        //    {
        //        strcat(newMsg->MsgData, szOpenBracket);
        //        AppendIntStr(newMsg->MsgData, (nRoleID + 1), Pad_0);
        //        strcat(newMsg->MsgData, szCloseBracketSpace);
        //        strcat(newMsg->MsgData, szOpenBracket);

        //        pcData = (char)&newMsg->MsgData[strlen(newMsg->MsgData)];

        //        memcpy((void)pcData,
        //                        (void)m_pVcsExManage[VIC_ExNo].Roles[nRoleID].szRoleName,
        //                        sizeof(m_pVcsExManage[VIC_ExNo].Roles[nRoleID].szRoleName));

        //    strcat(newMsg->MsgData, szCloseBracketSpace);
        //    }

        //    strcat(newMsg->MsgData, szEndSpace);


        //    strcat(newMsg->MsgData, "CALL_TIMEOUT [50] ");

        //    /* Network Definition */
        //    strcat(newMsg->MsgData, "START_NET_DEFS ");

        //	if (IL_IDX != VIC_ExNo)
        //	{

        //        strcat(newMsg->MsgData, "NET_DEF [POINT] ");		//AMS Actors (DA Channels)

        //        strcat(newMsg->MsgData, "ANSWER [Y] ");

        //        strcat(newMsg->MsgData, "CONNECT_DELAY [0] ");

        //        strcat(newMsg->MsgData, "A_IDENT_XFR [Y] ");

        //        strcat(newMsg->MsgData, "BUSY_MARK_IND [N] ");

        //        strcat(newMsg->MsgData, "BREAK_IN [N] ");

        //        strcat(newMsg->MsgData, "MONITOR_RADIO [N] ");

        //        strcat(newMsg->MsgData, "EXTERNAL [Y] ");

        //		for (nRoleID=1; nRoleID<=m_pVcsExManage[VIC_ExNo].sActorCount; ++nRoleID)
        //		{

        //            strcpy(szTemp, szPointDAAddress);
        //nTens = nRoleID/10;
        //			nUnits = nRoleID % 10;

        //			szTemp[10]  = '0' + nTens;
        //			szTemp[11] = '0' + nUnits;


        //            strcat(newMsg->MsgData, szTemp);
        //		}

        //        strcat(newMsg->MsgData, szEndSpace);
        //	}


        //    strcat(newMsg->MsgData, "NET_DEF [CABIN] ");		//Intercom (DA Channels)

        //    strcat(newMsg->MsgData, "ANSWER [N] ");

        //    strcat(newMsg->MsgData, "CONNECT_DELAY [0] ");

        //    strcat(newMsg->MsgData, "A_IDENT_XFR [N] ");

        //    strcat(newMsg->MsgData, "BUSY_MARK_IND [N] ");

        //    strcat(newMsg->MsgData, "BREAK_IN [N] ");

        //    strcat(newMsg->MsgData, "MONITOR_RADIO [N] ");

        //    strcat(newMsg->MsgData, "EXTERNAL [N] ");


        //    strcat(newMsg->MsgData, szCabinDAAddress);		//Instructor Intercom

        //	if ((IL_IDX != VIC_ExNo) && (!m_pVcsExManage[VIC_ExNo].bIndividualTraining))
        //	{
        //		for (i=0; i<m_sTotalNumDesks; i++)					//Trainee Intercom
        //		{

        //            strcpy(szTemp, szCabinDAAddress);

        //nDesk = 2* i + 1;
        //			nTens =		nDesk/10;
        //			nUnits = nDesk%10;

        //			szTemp[6]  = '0' + nTens;
        //			szTemp[7] = '0' + nUnits;

        //			nDesk += 1;
        //			nTens =		nDesk/10;
        //			nUnits = nDesk%10;

        //			szTemp[8]  = '0' + nTens;
        //			szTemp[9] = '0' + nUnits;


        //            strcat(newMsg->MsgData, szTemp);	
        //		}
        //	}

        //    strcat(newMsg->MsgData, szEndSpace);

        //    strcat(newMsg->MsgData, szEndSpace);

        //newMsg->MsgHeader.usLength = strlen(newMsg->MsgData) + 1;
        //	newMsg->nMsgSize = newMsg->MsgHeader.usLength + sizeof (vcsHeader_t);
        //	m_pVcsExManage[VIC_ExNo].nMsgCnt++;

        //	/* I_ES_ROLE_DEF */
        //	for (nRoleID=0; nRoleID<m_pVcsExManage[VIC_ExNo].sRoleCount; ++nRoleID)
        //	{
        //		if (!(newMsg = AddMessageToQueue(VIC_ExNo, F_LOAD)))
        //		{

        //            ReleaseMutex(m_pVcsExManage[VIC_ExNo].hQueueMutex);
        //			return M_ERROR;
        //		}

        //        /* Ensure null termination of data string when concatinating fixed length character arrays */
        //        memset((void*) newMsg->MsgData, 0, sizeof(newMsg->MsgData));

        //		newMsg->MsgHeader.sID = (ushort) I_ES_ROLE_DEF;
        //		newMsg->nMsgSize = 1;
        //		newMsg->MsgHeader.sReserved = 0;

        //		newMsg->sMsgExpectedReply = A_ES_ROLE_DEF;


        //        strcpy(newMsg->MsgData, "ROLE_ID [");

        //pcData = (char*) &newMsg->MsgData[strlen(newMsg->MsgData)];


        //        memcpy(	(void*)pcData, 
        //						(void*)m_pVcsExManage[VIC_ExNo].Roles[nRoleID].szRoleName,
        //						sizeof(m_pVcsExManage[VIC_ExNo].Roles[nRoleID].szRoleName));

        //		pcData= (char*) &newMsg->MsgData[strlen(newMsg->MsgData)];


        //        strcat(newMsg->MsgData, szCloseBracketSpace);

        //        strcat(newMsg->MsgData, "ROLE_TYPE [");

        //		switch (m_pVcsExManage[VIC_ExNo].Roles[nRoleID].sRoleType)
        //		{
        //			case CSystemComponent::SPARK_INSTRUCTOR:

        //                strcat(newMsg->MsgData, "INSTRUCTOR");
        //				break;
        //			case CSystemComponent::SPARK_TRAINEE_OPERATOR:

        //                strcat(newMsg->MsgData, "TRAINEE");
        //				break;
        //			default:
        //				return M_ERROR;
        //		}


        //        strcat(newMsg->MsgData, szCloseBracketSpace);


        //        strcat(newMsg->MsgData, "LOCATION [");

        //pcData = (char) &newMsg->MsgData[strlen(newMsg->MsgData)];


        //        memcpy(	(void*)pcData, 
        //						(void*)m_pVcsExManage[VIC_ExNo].Roles[nRoleID].szPlatform,
        //						sizeof(m_pVcsExManage[VIC_ExNo].Roles[nRoleID].szPlatform));	//Full Platform Name



        //        strcat(newMsg->MsgData, szCloseBracketOpenBracket);


        //pcData = (char) &newMsg->MsgData[strlen(newMsg->MsgData)];


        //        memcpy(	(void*)pcData, 
        //						(void*)m_pVcsExManage[VIC_ExNo].Roles[nRoleID].szAbbrPlatform,
        //						sizeof(m_pVcsExManage[VIC_ExNo].Roles[nRoleID].szAbbrPlatform));		//Abbreviated Platform Name


        //        strcat(newMsg->MsgData, szCloseBracketSpace);


        //        strcat(newMsg->MsgData, "A_IDENT_XFR [N] ");


        //        strcat(newMsg->MsgData, "NETWORK_ACCESS [POINT][CABIN] ");

        //		for (i=0; i<m_pVcsExManage[VIC_ExNo].sRadioCount; ++i)
        //		{
        //			if ((m_pVcsExManage[VIC_ExNo].Roles[nRoleID].nAssignedRadios >>i) & 1)
        //			{	/* Radio assigned */

        //                strcat(newMsg->MsgData, "RADIO_CHANNEL [");

        //pcData = (char) &newMsg->MsgData[strlen(newMsg->MsgData)];


        //                memcpy(	(void*)pcData, 
        //								(void*)m_pVcsExManage[VIC_ExNo].Radio[i].szFrequency,
        //								sizeof(m_pVcsExManage[VIC_ExNo].Radio[i].szFrequency));


        //                strcat(newMsg->MsgData, szCloseBracketSpace);


        //                strcat(newMsg->MsgData, szOpenBracket);

        //pcData = (char) &newMsg->MsgData[strlen(newMsg->MsgData)];


        //                memcpy(	(void)pcData, 
        //								(void)m_pVcsExManage[VIC_ExNo].Radio[i].szStation,
        //								sizeof(m_pVcsExManage[VIC_ExNo].Radio[i].szStation));


        //                strcat(newMsg->MsgData, szCloseBracketSpace);


        //                strcat(newMsg->MsgData, szOpenBracket);

        //                sprintf(szTemp, "");

        //                AppendIntStr(szTemp, m_pVcsExManage[VIC_ExNo].Radio[i].sKeyNumber, Pad_0);

        //                strcat(newMsg->MsgData, szTemp);

        //                strcat(newMsg->MsgData, szCloseBracketSpace);


        //                strcat(newMsg->MsgData, "INIT_STATE [DESELECT] ");

        //                strcat(newMsg->MsgData, "DESELECT_ENABLE [Y] ");

        //                strcat(newMsg->MsgData, "SPECIAL_EFFECT [");

        //                strcat(newMsg->MsgData, szRadioType[m_pVcsExManage[VIC_ExNo].Radio[i].sType]);

        //				if (eHF == m_pVcsExManage[VIC_ExNo].Radio[i].sType)

        //                    strcat(newMsg->MsgData, "][0] ");	//Level still to be defined by customer
        //				else

        //                    strcat(newMsg->MsgData, "][0] ");	//Level still to be defined by customer


        //                strcat(newMsg->MsgData, "END ");
        //			}
        //		}

        //		for (i=0; i<m_pVcsExManage[VIC_ExNo].sActorCount; ++i)
        //		{
        //			if ((m_pVcsExManage[VIC_ExNo].Roles[nRoleID].nAssignedActors >> i) & 1)
        //			{	/* Actor assigned */

        //                strcat(newMsg->MsgData, "DA [");


        //                sprintf(szTemp, "");

        //                AppendIntStr(szTemp, m_pVcsExManage[VIC_ExNo].Actor[i].sKeyNumber, Pad_0);

        //                strcat(newMsg->MsgData, szTemp);

        //                strcat(newMsg->MsgData, szCloseBracketOpenBracket);

        //pcData = (char) &newMsg->MsgData[strlen(newMsg->MsgData)];


        //                memcpy(	(void*) pcData, 
        //								(void*)m_pVcsExManage[VIC_ExNo].Actor[i].szPlatform,
        //								sizeof(m_pVcsExManage[VIC_ExNo].Actor[i].szPlatform));


        //                strcat(newMsg->MsgData, szCloseBracketOpenBracket);

        //pcData = (char) &newMsg->MsgData[strlen(newMsg->MsgData)];


        //                memcpy(	(void) pcData, 
        //								(void*)m_pVcsExManage[VIC_ExNo].Actor[i].szRoleName,
        //								sizeof(m_pVcsExManage[VIC_ExNo].Actor[i].szRoleName));


        //                strcat(newMsg->MsgData, "][POINT][");


        //                strcpy(szTemp, "5000");

        //nTens = (i+1)/10;
        //				nUnits = (i+1) % 10;

        //				szTemp[4] = '0' + nTens;
        //				szTemp[5] = '0' + nUnits;
        //				szTemp[6] = ']';
        //				szTemp[7] = ' ';
        //				szTemp[8] = '\0';


        //                strcat(newMsg->MsgData, szTemp);			
        //			}
        //		}

        //		/* Intercom */
        //		if (CSystemComponent::SPARK_INSTRUCTOR == m_pVcsExManage[VIC_ExNo].Roles[nRoleID].sRoleType)

        //            strcat(newMsg->MsgData, "DA [INTERCOM][Instruct][Intercom][CABIN][1111]");
        //		else if ((VIC_ExNo != IL_IDX) && 
        //						 !m_pVcsExManage[VIC_ExNo].bIndividualTraining &&
        //						 (m_pVcsExManage[VIC_ExNo].Roles[nRoleID].sPhysicalNode != DESK_OFFSET + m_sTotalNumNodes))
        //		{	/*Trainee Intercom [0102] etc */

        //            strcat(newMsg->MsgData, "DA [INTERCOM][Platform][Intercom][CABIN][");


        //            sprintf(szTemp, "0000");

        //nDesk = (m_pVcsExManage[VIC_ExNo].Roles[nRoleID].sPhysicalNode - DESK_OFFSET - 1)/2;
        //			nDesk *= 2;
        //			nDesk += 1;

        //			nTens = nDesk/10;
        //			nUnits = nDesk % 10;

        //			szTemp[0] = '0' + nTens;
        //			szTemp[1] = '0' + nUnits;

        //			nDesk += 1;

        //			nTens = nDesk/10;
        //			nUnits = nDesk % 10;

        //			szTemp[2] = '0' + nTens;
        //			szTemp[3] = '0' + nUnits;


        //            strcat(newMsg->MsgData, szTemp);

        //            strcat(newMsg->MsgData, szCloseBracketSpace);	

        //		}


        //        strcat(newMsg->MsgData, "END ");

        //newMsg->nMsgSize += strlen(newMsg->MsgData);

        //		if (newMsg->nMsgSize > (TX_DATA_SEGMENT_SIZE - sizeof (vcsHeader_t)))
        //			return M_ERROR;	

        //		newMsg->MsgHeader.usLength = (USHORT) newMsg->nMsgSize;	
        //		newMsg->nMsgSize += sizeof (vcsHeader_t);
        //		m_pVcsExManage[VIC_ExNo].nMsgCnt++;
        //	}

        //	/* I_ES_END */
        //	if (!(newMsg = AddMessageToQueue(VIC_ExNo, F_LOAD)))
        //	{

        //        ReleaseMutex(m_pVcsExManage[VIC_ExNo].hQueueMutex);
        //		return M_ERROR;
        //	}

        //	newMsg->MsgHeader.sID = (ushort) I_ES_END;
        //	newMsg->MsgHeader.usLength = (ushort) 0;	
        //	newMsg->nMsgSize = sizeof (vcsHeader_t);
        //	newMsg->MsgHeader.sReserved = 0;

        //	newMsg->sMsgExpectedReply = A_ES_END;
        //	m_pVcsExManage[VIC_ExNo].nMsgCnt++;


        //    ReleaseMutex(m_pVcsExManage[VIC_ExNo].hQueueMutex);

        //	return M_SUCCESS;
        //}

        ////////////////////////////////////////////////////////////////////////////////
        // Function   : LoadVcsExercise
        // Description: Creates the appropriate load or replay message for VCS which will 
        //							be used to extract a VCS exercise identity for the defined AMS  
        //							exercise (or IL Session). 
        ////////////////////////////////////////////////////////////////////////////////
        //##ModelId=4119F591032C
        public bool LoadVcsExercise(int VIC_ExNo)
        {
            QueuedMsg_t newMsg;

            char szTemp1[50];
            //char szTemp2[25];
            short psData;

            if (WAIT_TIMEOUT == WaitForSingleObject(m_pVcsExManage[VIC_ExNo].hQueueMutex, 2000))
                return M_ERROR;


            /* I_EC_LOAD or I_EC_REPLAY */
            switch (m_pVcsExManage[VIC_ExNo].eLoadType)
            {
                case EXERCISE_NEW:
                    /* I_EC_LOAD */
                    if (!(newMsg = AddMessageToQueue(VIC_ExNo, F_LOAD)))
                    {
                        ReleaseMutex(m_pVcsExManage[VIC_ExNo].hQueueMutex);
                        return M_ERROR;
                    }

                    newMsg->MsgHeader.sID = (USHORT)I_EC_LOAD;
                    newMsg->MsgHeader.sReserved = 0;

                    newMsg->sMsgExpectedReply = A_EC_LOAD;

                    memcpy((void)newMsg->MsgData,
                                    (void)m_pVcsExManage[VIC_ExNo].szUniqueExerciseName,
                                    sizeof(m_pVcsExManage[VIC_ExNo].szUniqueExerciseName));

                    newMsg->nMsgSize = sizeof(m_pVcsExManage[VIC_ExNo].szUniqueExerciseName);

                    memcpy((void)&newMsg->MsgData[newMsg->nMsgSize],
                                    (void)m_pVcsExManage[VIC_ExNo].szExerciseSpecificationName,
                                    sizeof(m_pVcsExManage[VIC_ExNo].szExerciseSpecificationName));

                    newMsg->nMsgSize += sizeof(m_pVcsExManage[VIC_ExNo].szExerciseSpecificationName);

                    GetTimeStr(szTemporaryTime, m_pVcsExManage[VIC_ExNo].dScenarioTime);

                    sprintf(m_szTrace, "Loading scenario time = %s\n", szTemporaryTime);
                    Console.WriteLine("");

                    strcpy((char)&newMsg->MsgData[newMsg->nMsgSize], szTemporaryTime);

                    newMsg->nMsgSize += strlen((char*)&newMsg->MsgData[newMsg->nMsgSize]); //overwriting null termination

                    psData = (short*)&newMsg->MsgData[newMsg->nMsgSize];
                    *psData++ = m_pVcsExManage[VIC_ExNo].sShortTermRecordControl;   //short term record request
                    *psData++ = m_pVcsExManage[VIC_ExNo].sLongTermRecordControl;        //long  term record request
                    newMsg->nMsgSize += 4;

                    sprintf(m_szTrace, "VCS RecordLog file '%s' \n", m_pVcsExManage[VIC_ExNo].szRecordFileName);
                    Console.WriteLine("");

                    if (strlen(m_pVcsExManage[VIC_ExNo].szRecordFileName) > 0)
                    {
                        sprintf(szTemp1, "_");
                        CTime theTime(CTime::GetCurrentTime());
                        sprintf(m_pVcsExManage[VIC_ExNo].szRecordFileIndex, "%s", theTime.Format("%d%m%Y%H%M%S"));
                        strcat(szTemp1, m_pVcsExManage[VIC_ExNo].szRecordFileIndex);

                        /* Add record file index to record name */
                        memcpy((void*)&newMsg->MsgData[newMsg->nMsgSize],
                                        (void*)m_pVcsExManage[VIC_ExNo].szRecordFileName,
                                        sizeof(m_pVcsExManage[VIC_ExNo].szRecordFileName));
                        memcpy((void)&newMsg->MsgData[newMsg->nMsgSize + strlen(m_pVcsExManage[VIC_ExNo].szRecordFileName)],
                                        (void*)szTemp1,
                                        strlen(szTemp1));
                    }
                    else
                    {
                        memset((void*)&newMsg->MsgData[newMsg->nMsgSize], 0, sizeof(m_pVcsExManage[VIC_ExNo].szRecordFileName));
                        sprintf(m_szTrace, "VCS Exercise %d recording disabled\n", VIC_ExNo);
                        Console.WriteLine("");
                    }

                    newMsg->nMsgSize += sizeof(m_pVcsExManage[VIC_ExNo].szRecordFileName);
                    break;

                case EXERCISE_REPLAY:
                case EXERCISE_RECOVERY:  //no longer utilised
                                         /* I_EC_REPLAY */
                    if (!(newMsg = AddMessageToQueue(VIC_ExNo, F_LOAD)))
                    {
                        ReleaseMutex(m_pVcsExManage[VIC_ExNo].hQueueMutex);
                        return M_ERROR;
                    }

                    newMsg->MsgHeader.sID = (USHORT)I_EC_REPLAY;
                    newMsg->MsgHeader.sReserved = 0;

                    newMsg->sMsgExpectedReply = A_EC_REPLAY;

                    memcpy((void*)newMsg->MsgData,
                                    (void)m_pVcsExManage[VIC_ExNo].szUniqueExerciseName,
                                    sizeof(m_pVcsExManage[VIC_ExNo].szUniqueExerciseName));

                    newMsg->nMsgSize = sizeof(m_pVcsExManage[VIC_ExNo].szUniqueExerciseName);

                    memcpy((void)&newMsg->MsgData[newMsg->nMsgSize],
                                    (void*)m_pVcsExManage[VIC_ExNo].szExerciseSpecificationName,
                                    sizeof(m_pVcsExManage[VIC_ExNo].szExerciseSpecificationName));

                    newMsg->nMsgSize += sizeof(m_pVcsExManage[VIC_ExNo].szExerciseSpecificationName);

                    if (strlen(m_pVcsExManage[VIC_ExNo].szRecordFileName) > 0)
                    {
                        /* Add replay file index to replay name */
                        CTime theTime(CTime::GetCurrentTime());
                        GetPrivateProfileString("Recording",
                                                                        "VcsIndex",
                                                                        theTime.Format("%d%m%Y%H%M%S"),
                                                                        m_pVcsExManage[VIC_ExNo].szRecordFileIndex,
                                                                        sizeof(m_pVcsExManage[VIC_ExNo].szRecordFileIndex), 
																m_pVcsExManage[VIC_ExNo].szLogFileName );

#if _VIC_CMND_STATUS_TRACE
						sprintf(m_szTrace, "Exercise Index %s \n", m_pVcsExManage[VIC_ExNo].szRecordFileIndex);
						Console.WriteLine("");
#endif

                        sprintf(szTemp1, "_");
                        strcat(szTemp1, m_pVcsExManage[VIC_ExNo].szRecordFileIndex);
                    }


                    memcpy((void*)&newMsg->MsgData[newMsg->nMsgSize],
                                    (void*)m_pVcsExManage[VIC_ExNo].szRecordFileName,
                                    sizeof(m_pVcsExManage[VIC_ExNo].szRecordFileName));
                    memcpy((void*)&newMsg->MsgData[newMsg->nMsgSize + strlen(m_pVcsExManage[VIC_ExNo].szRecordFileName)],
                                    (void*)szTemp1,
                                    strlen(szTemp1));

                    newMsg->nMsgSize += sizeof(m_pVcsExManage[VIC_ExNo].szRecordFileName) ;
                    break;

                default:
                    SendLoggerMessage(T_AMS_EXM, VIC_ExNo, "Unknown exercise load type");
                    ReleaseMutex(m_pVcsExManage[VIC_ExNo].hQueueMutex);
                    return M_ERROR;
                    break;
            }

            newMsg->MsgHeader.usLength = (ushort)newMsg->nMsgSize;
            newMsg->nMsgSize += sizeof(vcsHeader_t);
            m_pVcsExManage[VIC_ExNo].nMsgCnt++;

            /* Rearrange queue to delay messages queued having no VCS Exercise Number Set */
            //RearrangeMsgQueue(VIC_ExNo);

            /* Signal message ready to send */
            m_pVcsExManage[VIC_ExNo].eED_State = ED_WAITING;

            if (MESSAGE_IDLE == m_pVcsExManage[VIC_ExNo].eMsgStatus)
                m_pVcsExManage[VIC_ExNo].eMsgStatus = MESSAGE_READY;

            ReleaseMutex(m_pVcsExManage[VIC_ExNo].hQueueMutex);

            return M_SUCCESS;
        }

        ////////////////////////////////////////////////////////////////////////////////
        // Function   : AllocVcsExercise
        // Description: Creates messages for VCS which allocate desks to the exercise,
        //							login the associated instructor/actor roles to these desks and
        //							define the current audio recording configuration
        ////////////////////////////////////////////////////////////////////////////////
        //##ModelId=4119F5910368
        public bool AllocVcsExercise(int VIC_ExNo)
        {

            QueuedMsg_t newMsg;
            ushort psData;

            short i, n;

            if (WAIT_TIMEOUT == WaitForSingleObject(m_pVcsExManage[VIC_ExNo].hQueueMutex, 2000))
                return M_ERROR;

            switch (m_pVcsExManage[VIC_ExNo].eLoadType)
            {

                case EXERCISE_RECOVERY:     //no longer utilised
                case EXERCISE_NEW:

                    /* I_EC_ALLOC */
                    if (!(newMsg = AddMessageToQueue(VIC_ExNo, F_LOGIN)))
                    {
                        ReleaseMutex(m_pVcsExManage[VIC_ExNo].hQueueMutex);
                        return M_ERROR;
                    }

                    newMsg->MsgHeader.sID = (USHORT)I_EC_ALLOC;
                    newMsg->MsgHeader.sReserved = 0;

                    newMsg->sMsgExpectedReply = A_EC_ALLOC;

                    psData = (ushort)&newMsg->MsgData;

                    (psData++) = m_pVcsExManage[VIC_ExNo].sVcsExerciseNumber;
                    (psData++) = m_pVcsExManage[VIC_ExNo].sRoleCount;

                    for (n = 0; n < m_pVcsExManage[VIC_ExNo].sRoleCount; n++)
                    {
                        for (i = 0; i < m_pVcsExManage[VIC_ExNo].sRoleCount; ++i)
                        {
                            if (m_pVcsExManage[VIC_ExNo].Roles[i].sLogicalNode == (n + 1))
                            {
                                (psData++) = m_pVcsExManage[VIC_ExNo].Roles[i].sPhysicalNode;
                                break;
                            }
                        }
                    }

                    newMsg->MsgHeader.usLength = 4 + (2 * m_pVcsExManage[VIC_ExNo].sRoleCount);
                    newMsg->nMsgSize = newMsg->MsgHeader.usLength + sizeof(vcsHeader_t);
                    m_pVcsExManage[VIC_ExNo].nMsgCnt++;

                    /* I_LOGIN  - Master instructor first */
                    for (n = 0; n < m_pVcsExManage[VIC_ExNo].sRoleCount; ++n)
                    {
                        /* All instructors are initially logged into IL exercise */
                        /* Only login trainees as required											 */
                        if (m_pVcsExManage[VIC_ExNo].Roles[n].sPhysicalNode != m_pVcsExManage[VIC_ExNo].sMasterInstPhysicalNode)
                            continue;

                        if (LoginVcsExercise(VIC_ExNo, n, false))
                        {
                            ReleaseMutex(m_pVcsExManage[VIC_ExNo].hQueueMutex);
                            return M_ERROR;
                        }
                        break;
                    }

                    /* I_LOGIN  - all other roles */
                    for (n = 0; n < m_pVcsExManage[VIC_ExNo].sRoleCount; ++n)
                    {
                        /* All instructors are initially logged into IL exercise */
                        /* Only login trainees as required											 */
                        if (((IL_IDX == VIC_ExNo) &&
                                            (CSystemComponent::SPARK_TRAINEE_OPERATOR == m_pVcsExManage[VIC_ExNo].Roles[n].sRoleType) &&
                                            (LOGIN_REQUESTED != m_pVcsExManage[VIC_ExNo].Roles[n].eLoginStatus)) ||
                                        (m_pVcsExManage[VIC_ExNo].Roles[n].sPhysicalNode == m_pVcsExManage[VIC_ExNo].sMasterInstPhysicalNode) ||
                                        (m_bSingleInstructor && (CSystemComponent::SPARK_INSTRUCTOR == m_pVcsExManage[VIC_ExNo].Roles[n].sRoleType)))
                            continue;

                        if (LoginVcsExercise(VIC_ExNo, n, false))
                        {
                            ReleaseMutex(m_pVcsExManage[VIC_ExNo].hQueueMutex);
                            return M_ERROR;
                        }
                    }

                    break;

                case EXERCISE_REPLAY:

                    /* I_EC_ALLOC */
                    if (!(newMsg = AddMessageToQueue(VIC_ExNo, F_LOGIN)))
                    {
                        ReleaseMutex(m_pVcsExManage[VIC_ExNo].hQueueMutex);
                        return M_ERROR;
                    }

                    newMsg->MsgHeader.sID = (USHORT)I_EC_ALLOC;
                    newMsg->MsgHeader.sReserved = 0;

                    newMsg->sMsgExpectedReply = A_EC_ALLOC;

                    psData = (USHORT*)&newMsg->MsgData;

                    *(psData++) = m_pVcsExManage[VIC_ExNo].sVcsExerciseNumber;
                    *(psData++) = m_pVcsExManage[VIC_ExNo].sRoleCount;                  //Qty Physical nodes	

                    for (n = 0; n < m_pVcsExManage[VIC_ExNo].sRoleCount; n++)
                    {
                        if (n == 0)
                            *(psData++) = m_sDebriefNode + DESK_OFFSET;     //Debrief node
                        else
                            *(psData++) = 0;                                                        //Position not used
                    }

                    newMsg->MsgHeader.usLength = 4 + (2 * m_pVcsExManage[VIC_ExNo].sRoleCount);
                    newMsg->nMsgSize = newMsg->MsgHeader.usLength + sizeof(vcsHeader_t);
                    m_pVcsExManage[VIC_ExNo].nMsgCnt++;

                    /*	No login here - login is handled within RecordReplayControl() function when called with
                            respect to replay (parameter eRP_ON_MODIFY).This enables logout of previous trainee (if 
                            required), login of trainee then revision to RP configuration														*/

                    break;

                default:
                    ReleaseMutex(m_pVcsExManage[VIC_ExNo].hQueueMutex);
                    return M_ERROR;
                    break;

            }

            /* I_CONNECTIVITY */
            //Not handled here - all radios are enabled at the VCS by default - masking is via messages from exercise.

            /* I_EC_SEEK */
            //No seek required during exercise preparation - always done via load snapshot message

            /* Record/Replay Control */
            if (EXERCISE_RECOVERY == m_pVcsExManage[VIC_ExNo].eLoadType) // no longer utilised
            {   // Need to specify all nodes before converting exercise from playback to record type
                if (RecordReplayControl(VIC_ExNo, NULL, eRP_ON_ALL))
                    return M_ERROR;
            }
            else
            {
                if (RecordReplayControl(VIC_ExNo, NULL, eRP_ON_PREVIOUS))   //ensures record config set prior to start is not lost
                    return M_ERROR;
            }

            /* Signal message ready to send */
            if (MESSAGE_IDLE == m_pVcsExManage[VIC_ExNo].eMsgStatus)
                m_pVcsExManage[VIC_ExNo].eMsgStatus = MESSAGE_READY;

            ReleaseMutex(m_pVcsExManage[VIC_ExNo].hQueueMutex);

            return M_SUCCESS;

        }

        ////////////////////////////////////////////////////////////////////////////////
        // Function   : StartVcsExercise
        // Description: Creates a message for VCS to start/resume or playback an exercise
        //							(as appropriate).
        ////////////////////////////////////////////////////////////////////////////////
        //##ModelId=4119F592005D
        public bool StartVcsExercise(int VIC_ExNo)
        {

            QueuedMsg_t newMsg;
            ushort psData;

            if (WAIT_TIMEOUT == WaitForSingleObject(m_pVcsExManage[VIC_ExNo].hQueueMutex, 2000))
                return M_ERROR;

            /* Create appropriate 'start' message */
            if (!(newMsg = AddMessageToQueue(VIC_ExNo, F_START)))
            {
                ReleaseMutex(m_pVcsExManage[VIC_ExNo].hQueueMutex);
                return M_ERROR;
            }

            newMsg->MsgHeader.sReserved = 0;

            switch (m_pVcsExManage[VIC_ExNo].eLoadType)
            {
                /* I_EC_START */
                case UNET_Classes. EXERCISE_NEW:
                case EXERCISE_RECOVERY: // no longer utilised

                    /* Write active filename to log file */
                    if (m_pVcsExManage[VIC_ExNo].sShortTermRecordControl)
                    {
                        /*
                                        //get the log gile name and change the extension to the temporary name
                                        std::string strLogFile(m_pVcsExManage[VIC_ExNo].szLogFileName);
                                        strLogFile = strLogFile.substr(0,strLogFile.length()-4) + ".log";

                                        std::string::size_type nPos = strLogFile.find(m_pSystem->GetLogFilePath());
                                        if ( nPos != -1 )
                                        {
                                            strLogFile.replace(nPos, m_pSystem->GetLogFilePath().length(), m_pSystem->GetTempLogFilePath());
                                        }

                                        WritePrivateProfileString ("Recording","VcsIndex", m_pVcsExManage[VIC_ExNo].szRecordFileIndex , strLogFile.c_str() );
                        */
                        // Send a message to the logger so it can update the .log file.
                        msgVCSSetIndex_T msgSetIndex;
                        msgSetIndex.lMessageID = eMsg_VCS_SET_INDEX;
                        msgSetIndex.lMessageType = eSIMPLE_MESSAGE;
                        msgSetIndex.nExerciseID = VIC_ExNo;
                        strcpy(msgSetIndex.szIndex, m_pVcsExManage[VIC_ExNo].szRecordFileIndex);

                        m_pSEI->SendMessage(eMsg_VCS_SET_INDEX, CONTROL_EXERCISE, CSystemComponent::instance()->GetLoggerAppID(), 0, sizeof(msgVCSSetIndex_T), &msgSetIndex);
                    }


#if _VIC_CMND_STATUS_TRACE
						sprintf(m_szTrace, "Exercise Index %s \n", m_pVcsExManage[VIC_ExNo].szRecordFileIndex);
						Console.WriteLine("");
#endif

                    MsgHeader.sID = (ushort)I_EC_START;
                    newMsg->sMsgExpectedReply = A_EC_START;
                    break;

                /* I_EC_PLAYBACK */
                case EXERCISE_REPLAY:
                    newMsg->MsgHeader.sID = (USHORT)I_EC_PLAYBACK;
                    newMsg->sMsgExpectedReply = A_EC_PLAYBACK;
                    break;

                default:
                    ReleaseMutex(m_pVcsExManage[VIC_ExNo].hQueueMutex);
                    return M_ERROR;
                    break;
            }

            psData = (ushort)&newMsg->MsgData;
            (psData++) = m_pVcsExManage[VIC_ExNo].sVcsExerciseNumber;

            newMsg->MsgHeader.usLength = 2;
            newMsg->nMsgSize = newMsg->MsgHeader.usLength + sizeof(vcsHeader_t);
            m_pVcsExManage[VIC_ExNo].nMsgCnt++;

            /* Signal message ready to send */
            if (MESSAGE_IDLE == m_pVcsExManage[VIC_ExNo].eMsgStatus)
                m_pVcsExManage[VIC_ExNo].eMsgStatus = MESSAGE_READY;

            ReleaseMutex(m_pVcsExManage[VIC_ExNo].hQueueMutex);

            return M_SUCCESS;

        }

        ////////////////////////////////////////////////////////////////////////////////
        // Function   : ResumeVcsExercise
        // Description: This converts a playback exercise into a recording exercise							
        ////////////////////////////////////////////////////////////////////////////////
        //##ModelId=4119F592008F
        public bool ResumeVcsExercise(int VIC_ExNo)
        {

            QueuedMsg_t newMsg;
            ushort psData;

            if (WAIT_TIMEOUT == WaitForSingleObject(m_pVcsExManage[VIC_ExNo].hQueueMutex, 2000))
                return M_ERROR;

            /* Create appropriate 'start' message */
            if (!(newMsg = AddMessageToQueue(VIC_ExNo, F_START)))
            {
                ReleaseMutex(m_pVcsExManage[VIC_ExNo].hQueueMutex);
                return M_ERROR;
            }

            newMsg->MsgHeader.sReserved = 0;
            newMsg->MsgHeader.sID = (USHORT)I_EC_RESUME;
            newMsg->sMsgExpectedReply = A_EC_RESUME;

            psData = (USHORT*)&newMsg->MsgData;
            *(psData++) = m_pVcsExManage[VIC_ExNo].sVcsExerciseNumber;

            newMsg->MsgHeader.usLength = 2;
            newMsg->nMsgSize = newMsg->MsgHeader.usLength + sizeof(vcsHeader_t);
            m_pVcsExManage[VIC_ExNo].nMsgCnt++;

            /* Signal message ready to send */
            if (MESSAGE_IDLE == m_pVcsExManage[VIC_ExNo].eMsgStatus)
                m_pVcsExManage[VIC_ExNo].eMsgStatus = MESSAGE_READY;

            ReleaseMutex(m_pVcsExManage[VIC_ExNo].hQueueMutex);

            return M_SUCCESS;

        }


        ////////////////////////////////////////////////////////////////////////////////
        // Function   : LoginVcsExercise
        // Description: Creates a message for VCS which logs an instructor or trainee role
        //							into a specific (logical) communication node.  Normally logout
        //							is controlled via SPARK unload command
        ////////////////////////////////////////////////////////////////////////////////
        //##ModelId=4119F591039A
        public bool LoginVcsExercise(int VIC_ExNo, int VIC_RoleNo, bool bSetReady)
        {

            QueuedMsg_t newMsg;
            Login_t pLoginMsg;

            if (WAIT_TIMEOUT == WaitForSingleObject(m_pVcsExManage[VIC_ExNo].hQueueMutex, 2000))
                return M_ERROR;


            if (!(newMsg = AddMessageToQueue(VIC_ExNo, F_LOGIN)))
            {
                ReleaseMutex(m_pVcsExManage[VIC_ExNo].hQueueMutex);
                return M_ERROR;
            }

            newMsg->MsgHeader.sID = (USHORT)I_LOGIN;
            newMsg->MsgHeader.sReserved = 0;

            newMsg->sMsgExpectedReply = A_LOGIN;

            pLoginMsg = (Login_t*)&newMsg->MsgData;

            pLoginMsg->sExerciseNumber = m_pVcsExManage[VIC_ExNo].sVcsExerciseNumber;

            memcpy((void*)pLoginMsg->cRoleName,
                                (void*)m_pVcsExManage[VIC_ExNo].Roles[VIC_RoleNo].szRoleName,
                                sizeof(m_pVcsExManage[VIC_ExNo].Roles[VIC_RoleNo].szRoleName));

            /* Phone call from Troy (MGH) 10/09/09 */
            //if (EXERCISE_REPLAY == m_pVcsExManage[VIC_ExNo].eLoadType)
            //	pLoginMsg->sLogicalNode = 1;
            //else 		
            pLoginMsg->sLogicalNode = m_pVcsExManage[VIC_ExNo].Roles[VIC_RoleNo].sLogicalNode;

            newMsg->MsgHeader.usLength = sizeof(Login_t);
            newMsg->nMsgSize = newMsg->MsgHeader.usLength + sizeof(vcsHeader_t);
            m_pVcsExManage[VIC_ExNo].nMsgCnt++;

            ReleaseMutex(m_pVcsExManage[VIC_ExNo].hQueueMutex);

            /* Signal message ready to send */
            if ((bSetReady) && (MESSAGE_IDLE == m_pVcsExManage[VIC_ExNo].eMsgStatus))
                m_pVcsExManage[VIC_ExNo].eMsgStatus = MESSAGE_READY;

            return M_SUCCESS;

        }

        ////////////////////////////////////////////////////////////////////////////////
        // Function   : LogoutVcsExercise
        // Description: Creates a message for VCS which logs an instructor or trainee role
        //							out of a specific (logical) communication node.  
        ////////////////////////////////////////////////////////////////////////////////
        //##ModelId=4119F5920002
        public bool LogoutVcsExercise(int VIC_ExNo, int VIC_RoleNo, bool bSetReady)
        {

            QueuedMsg_t newMsg;
            Login_t pLoginMsg;

            if (WAIT_TIMEOUT == WaitForSingleObject(m_pVcsExManage[VIC_ExNo].hQueueMutex, 2000))
                return M_ERROR;


            if (!(newMsg = AddMessageToQueue(VIC_ExNo, F_LOGOUT)))
            {
                ReleaseMutex(m_pVcsExManage[VIC_ExNo].hQueueMutex);
                return M_ERROR;
            }

            newMsg->MsgHeader.sID = (USHORT)I_LOGOUT;
            newMsg->MsgHeader.sReserved = 0;

            newMsg->sMsgExpectedReply = A_LOGOUT;

            pLoginMsg = (Login_t*)&newMsg->MsgData;

            pLoginMsg->sExerciseNumber = m_pVcsExManage[VIC_ExNo].sVcsExerciseNumber;

            memcpy((void*)pLoginMsg->cRoleName,
                                (void*)m_pVcsExManage[VIC_ExNo].Roles[VIC_RoleNo].szRoleName,
                                sizeof(m_pVcsExManage[VIC_ExNo].Roles[VIC_RoleNo].szRoleName));

            /* Phone call from Troy (MGH) 10/09/09 */
            //if (EXERCISE_REPLAY == m_pVcsExManage[VIC_ExNo].eLoadType)
            //	pLoginMsg->sLogicalNode = 1;
            //else
            pLoginMsg->sLogicalNode = m_pVcsExManage[VIC_ExNo].Roles[VIC_RoleNo].sLogicalNode;

            newMsg->MsgHeader.usLength = sizeof(Login_t);
            newMsg->nMsgSize = newMsg->MsgHeader.usLength + sizeof(vcsHeader_t);
            m_pVcsExManage[VIC_ExNo].nMsgCnt++;

            ReleaseMutex(m_pVcsExManage[VIC_ExNo].hQueueMutex);

            /* Signal message ready to send */
            if ((bSetReady) && (MESSAGE_IDLE == m_pVcsExManage[VIC_ExNo].eMsgStatus))
                m_pVcsExManage[VIC_ExNo].eMsgStatus = MESSAGE_READY;

            return M_SUCCESS;
        }

        ////////////////////////////////////////////////////////////////////////////////
        // Function   : SeekVcsExercise
        // Description: Creates a message for VCS Seek command
        ////////////////////////////////////////////////////////////////////////////////
        //##ModelId=4119F5920279
        public bool SeekVcsExercise(int VIC_ExNo)
        {
            QueuedMsg_t newMsg;
            ushort psData;
            char szTemp;

            if (WAIT_TIMEOUT == WaitForSingleObject(m_pVcsExManage[VIC_ExNo].hQueueMutex, 2000))
                return M_ERROR;

            /* I_EC_SEEK */
            if (!(newMsg = AddMessageToQueue(VIC_ExNo, F_LOGIN)))
            {
                ReleaseMutex(m_pVcsExManage[VIC_ExNo].hQueueMutex);
                return M_ERROR;
            }

            newMsg->MsgHeader.sID = (USHORT)I_EC_SEEK;
            newMsg->MsgHeader.sReserved = 0;

            newMsg->sMsgExpectedReply = A_EC_SEEK;

            psData = (ushort*)&newMsg->MsgData;

            (psData++) = m_pVcsExManage[VIC_ExNo].sVcsExerciseNumber;

            szTemp = (char)psData;

            GetTimeStr(szTemporaryTime, m_pVcsExManage[VIC_ExNo].dExerciseTime);    //Active time used for replay
            sprintf(m_szTrace, "VCS Loading exercise time %s\n", szTemporaryTime);
            Console.WriteLine("");
            strcpy(szTemp, szTemporaryTime);
            strcat(szTemp, szSpace);

            GetTimeStr(szTemporaryTime, m_pVcsExManage[VIC_ExNo].dScenarioTime);    //Active time used during record
            sprintf(m_szTrace, "VCS Loading scenario time %s\n", szTemporaryTime);
            Console.WriteLine("");
            strcat(szTemp, szTemporaryTime);

            newMsg->MsgHeader.usLength = 3 + strlen(szTemp);
            newMsg->nMsgSize = newMsg->MsgHeader.usLength + sizeof(vcsHeader_t);
            m_pVcsExManage[VIC_ExNo].nMsgCnt++;

            /* Signal message ready to send */
            if (MESSAGE_IDLE == m_pVcsExManage[VIC_ExNo].eMsgStatus)
                m_pVcsExManage[VIC_ExNo].eMsgStatus = MESSAGE_READY;

            ReleaseMutex(m_pVcsExManage[VIC_ExNo].hQueueMutex);

            return M_SUCCESS;
        }

        ///////////////////////////////////////////////////////////////////////////////
        // Function   : PauseVcsExercise
        // Description: Creates a message for VCS which puts exercise into pause state
        ////////////////////////////////////////////////////////////////////////////////
        //##ModelId=4119F59200CB
        public bool PauseVcsExercise(int VIC_ExNo)
        {
            QueuedMsg_t newMsg;
            USHORT psData;

            if (WAIT_TIMEOUT == WaitForSingleObject(m_pVcsExManage[VIC_ExNo].hQueueMutex, 2000))
                return M_ERROR;

            /* I_EC_PAUSE */
            if (!(newMsg = AddMessageToQueue(VIC_ExNo, F_PAUSE)))
            {
                ReleaseMutex(m_pVcsExManage[VIC_ExNo].hQueueMutex);
                return M_ERROR;
            }

            newMsg->MsgHeader.sID = (USHORT)I_EC_PAUSE;

            /* Queue message but prevent transmission if a stop message has been queued 
            if (m_pVcsExManage[VIC_ExNo].bStoppingExercise)
                newMsg->MsgHeader.sReserved = 1;
            else
                newMsg->MsgHeader.sReserved = 0;
            */

            newMsg->MsgHeader.sReserved = 0;
            newMsg->sMsgExpectedReply = A_EC_PAUSE;

            psData = (USHORT*)&newMsg->MsgData;
            *(psData) = m_pVcsExManage[VIC_ExNo].sVcsExerciseNumber;

            newMsg->MsgHeader.usLength = 2;
            newMsg->nMsgSize = newMsg->MsgHeader.usLength + sizeof(vcsHeader_t);
            m_pVcsExManage[VIC_ExNo].nMsgCnt++;

            /* Signal message ready to send */
            if (MESSAGE_IDLE == m_pVcsExManage[VIC_ExNo].eMsgStatus)
                m_pVcsExManage[VIC_ExNo].eMsgStatus = MESSAGE_READY;

            ReleaseMutex(m_pVcsExManage[VIC_ExNo].hQueueMutex);

            return M_SUCCESS;
        }


        ////////////////////////////////////////////////////////////////////////////////
        // Function   : StopVcsExercise
        // Description: Creates a message for VCS which stops exercise.
        ////////////////////////////////////////////////////////////////////////////////
        //##ModelId=4119F59200FD
        public bool StopVcsExercise(int VIC_ExNo)
        {
            QueuedMsg_t* newMsg = NULL;
            USHORT* psData = NULL;

            if (WAIT_TIMEOUT == WaitForSingleObject(m_pVcsExManage[VIC_ExNo].hQueueMutex, 2000))
                return M_ERROR;

            // I_EC_STOP
            if (!(newMsg = AddMessageToQueue(VIC_ExNo, F_STOP)))
            {
                ReleaseMutex(m_pVcsExManage[VIC_ExNo].hQueueMutex);
                return M_ERROR;
            }

            newMsg->MsgHeader.sID = static_cast<USHORT>(I_EC_STOP);
            newMsg->MsgHeader.sReserved = 0;
            newMsg->sMsgExpectedReply = A_EC_STOP;

            psData = reinterpret_cast<USHORT*>(&newMsg->MsgData);
            *(psData) = m_pVcsExManage[VIC_ExNo].sVcsExerciseNumber;

            // If recording was not enabled, then delete the recording.
            if (!(m_bRecordingValid[VIC_ExNo]))
                *(psData + 1) = STOP_AND_DELETE_NO_ARCHIVE;
            else
                *(psData + 1) = STOP_DEFAULT;

            newMsg->MsgHeader.usLength = 4;
            newMsg->nMsgSize = newMsg->MsgHeader.usLength + sizeof(vcsHeader_t);
            m_pVcsExManage[VIC_ExNo].nMsgCnt++;

            // Prevent further messages being queued for this exercise - possible when using Session Manager block commands
            m_pVcsExManage[VIC_ExNo].bStoppingExercise = true;

            // Signal message ready to send
            if (MESSAGE_IDLE == m_pVcsExManage[VIC_ExNo].eMsgStatus)
                m_pVcsExManage[VIC_ExNo].eMsgStatus = MESSAGE_READY;

            ReleaseMutex(m_pVcsExManage[VIC_ExNo].hQueueMutex);

            return M_SUCCESS;
        }

        ////////////////////////////////////////////////////////////////////////////////
        // Function   : DeleteVcsExercise
        // Description: Creates a message for VCS which unloads the exercise thereby freeing
        //							exercise resources
        ////////////////////////////////////////////////////////////////////////////////
        //##ModelId=4119F5920139
        public bool DeleteVcsExercise(int VIC_ExNo, bool bForceStop)
        {
            QueuedMsg_t* newMsg = NULL;
            USHORT* psData = NULL;

            if (WAIT_TIMEOUT == WaitForSingleObject(m_pVcsExManage[VIC_ExNo].hQueueMutex, 2000))
                return M_ERROR;

            if (bForceStop)
            {
                /* I_EC_STOP */
                if (!(newMsg = AddMessageToQueue(VIC_ExNo, F_STOP)))
                {
                    ReleaseMutex(m_pVcsExManage[VIC_ExNo].hQueueMutex);
                    return M_ERROR;
                }

                newMsg->MsgHeader.sID = static_cast<USHORT>(I_EC_STOP);
                newMsg->MsgHeader.sReserved = 0;

                newMsg->sMsgExpectedReply = A_EC_STOP;

                psData = reinterpret_cast<USHORT*>(&newMsg->MsgData);
                *(psData) = m_pVcsExManage[VIC_ExNo].sVcsExerciseNumber;

                // If recording was not enabled, then delete the recording.
                if (!(m_bRecordingValid[VIC_ExNo]))
                    *(psData + 1) = STOP_AND_DELETE_NO_ARCHIVE;
                else
                    *(psData + 1) = STOP_DEFAULT;

                newMsg->MsgHeader.usLength = 4;
                newMsg->nMsgSize = newMsg->MsgHeader.usLength + sizeof(vcsHeader_t);
                m_pVcsExManage[VIC_ExNo].nMsgCnt++;
            }


            /* I_ES_DEL */
            if (!(newMsg = AddMessageToQueue(VIC_ExNo, F_LOAD)))
            {
                ReleaseMutex(m_pVcsExManage[VIC_ExNo].hQueueMutex);
                return M_ERROR;
            }

            newMsg->MsgHeader.sID = static_cast<USHORT>(I_ES_DEL);
            newMsg->MsgHeader.usLength = 1;
            newMsg->MsgHeader.sReserved = 0;

            newMsg->sMsgExpectedReply = A_ES_DEL;

            strcpy(newMsg->MsgData, m_pVcsExManage[VIC_ExNo].szExerciseSpecificationName);

            newMsg->MsgHeader.usLength += (USHORT)strlen(newMsg->MsgData);
            newMsg->nMsgSize = newMsg->MsgHeader.usLength + sizeof(vcsHeader_t);
            m_pVcsExManage[VIC_ExNo].nMsgCnt++;

            /* Signal message ready to send */
            if (MESSAGE_IDLE == m_pVcsExManage[VIC_ExNo].eMsgStatus)
                m_pVcsExManage[VIC_ExNo].eMsgStatus = MESSAGE_READY;

            m_pVcsExManage[VIC_ExNo].eED_State = ED_DELETE;

            ReleaseMutex(m_pVcsExManage[VIC_ExNo].hQueueMutex);

            return M_SUCCESS;

        }

        ////////////////////////////////////////////////////////////////////////////////
        // Function   : RecordReplayControl
        // Description: Configures the exercise record/replay structure and if required
        //							calls a function to create record/replay configuration message for VCS.
        //							At present recording is set for all or no trainee comms nodes.
        ////////////////////////////////////////////////////////////////////////////////
        //##ModelId=4119F59201ED
        public bool RecordReplayControl(int VIC_ExNo, int nNewReplayNodeIndex, eRecordPosition eRP)
        {
            /* Define record/replay node information */
            int nLastUsedNodeIndex = 0;
            int nLastReplayNodeIndex;

            switch (eRP)
            {
                case eRP_OFF_SAVE:  //RECORD ONLY 

                    /*	Take backup copy of previous configuration (for future reload) 
                            This option was intended for use when switching off recording due
                            to runspeed > x1 then reinstating recording (using eRP_ON_PREVIOUS)
                            when runspeed returned to x1.  However recording is to be made 
                            valid for all run speeds.  Retain code in case required again.
                    */

                    m_pVcsExManage[VIC_ExNo].sRPCountPrevious = m_pVcsExManage[VIC_ExNo].sRPCount;

                    for (; nLastUsedNodeIndex < m_pVcsExManage[VIC_ExNo].sRPCount; nLastUsedNodeIndex++)
                        m_pVcsExManage[VIC_ExNo].sRPNodePrevious[nLastUsedNodeIndex] = m_pVcsExManage[VIC_ExNo].sRPNode[nLastUsedNodeIndex];

                    m_pVcsExManage[VIC_ExNo].sRPPreviousValid = true;  //flags that previous config data is valid

                //fall-through

                case eRP_OFF:               //RECORD ONLY

                    /* Clear record configuration */

                    for (; nLastUsedNodeIndex < m_pVcsExManage[VIC_ExNo].sRPCount; nLastUsedNodeIndex++)
                        m_pVcsExManage[VIC_ExNo].sRPNode[nLastUsedNodeIndex] = 0;

                    m_pVcsExManage[VIC_ExNo].sRPCount = 0;

                    break;

                case eRP_ON_ALL:        //RECORD ONLY

                    /* Record every trainee node */

                    m_pVcsExManage[VIC_ExNo].sRPCount = m_pVcsExManage[VIC_ExNo].sRoleCount;

                    for (; nLastUsedNodeIndex < m_pVcsExManage[VIC_ExNo].sRoleCount; nLastUsedNodeIndex++)
                        m_pVcsExManage[VIC_ExNo].sRPNode[nLastUsedNodeIndex] = m_pVcsExManage[VIC_ExNo].Roles[nLastUsedNodeIndex].sPhysicalNode;

                    break;

                case eRP_ON_PREVIOUS:   //RECORD OR REPLAY

                    /* Restore previous configuration */

                    if (m_pVcsExManage[VIC_ExNo].sRPPreviousValid)
                    {
                        m_pVcsExManage[VIC_ExNo].sRPCount = m_pVcsExManage[VIC_ExNo].sRPCountPrevious;

                        for (; nLastUsedNodeIndex < m_pVcsExManage[VIC_ExNo].sRPCount; nLastUsedNodeIndex++)
                        {
                            m_pVcsExManage[VIC_ExNo].sRPNode[nLastUsedNodeIndex] = m_pVcsExManage[VIC_ExNo].sRPNodePrevious[nLastUsedNodeIndex];
                        }
                    }
                    else
                        nLastUsedNodeIndex = m_pVcsExManage[VIC_ExNo].sRPCount;

                    break;

                case eRP_ON_MODIFY: //REPLAY ONLY

                    /* find existing replay role from debrief station for logout later */
                    nLastReplayNodeIndex = -1;

                    if (m_pVcsExManage[VIC_ExNo].sRPCount)
                    {
                        nLastReplayNodeIndex = 0;
                        while ((m_pVcsExManage[VIC_ExNo].Roles[nLastReplayNodeIndex].sPhysicalNode != m_pVcsExManage[VIC_ExNo].sRPNode[0]) &&
                         (nLastReplayNodeIndex < m_pVcsExManage[VIC_ExNo].sRoleCount))
                            nLastReplayNodeIndex++;

                        if (nLastReplayNodeIndex == m_pVcsExManage[VIC_ExNo].sRoleCount)
                        {
                            ReleaseMutex(m_pVcsExManage[VIC_ExNo].hQueueMutex);
                            return M_ERROR;
                        }
                    }

                    /* select trainee node for replay */
                    m_pVcsExManage[VIC_ExNo].sRPCount = 1;
                    m_pVcsExManage[VIC_ExNo].sRPNode[0] = m_pVcsExManage[VIC_ExNo].Roles[nNewReplayNodeIndex].sPhysicalNode;
                    nLastUsedNodeIndex = 1;

                    break;

            }

            /* Clear UNUSED RPNode elements */
            for (; nLastUsedNodeIndex < m_sTotalNumNodes; ++nLastUsedNodeIndex)
                m_pVcsExManage[VIC_ExNo].sRPNode[nLastUsedNodeIndex] = 0;

            /* Logout previous replay role then login new one */
            /* Note that eRP_ON_MODIFY only valid if exercise loaded														*/
            if (eRP_ON_MODIFY == eRP)
            {
                if ((nLastReplayNodeIndex != -1) && (nLastReplayNodeIndex != nNewReplayNodeIndex))
                {
                    if (LogoutVcsExercise(VIC_ExNo, nLastReplayNodeIndex, false))       //Logging out of logical node 1 as in replay mode
                        return M_ERROR;
                }
            }

            /* Only send message when VCS exercise number known				*/
            /* If not known message will automatically be sent later	*/
            if (m_pVcsExManage[VIC_ExNo].sVcsExerciseNumber > 0)
            {
                if (LoadRpConfig(VIC_ExNo))
                    return M_ERROR;
            }

            if (eRP_ON_MODIFY == eRP)
            {
                /* login new role */
                if (LoginVcsExercise(VIC_ExNo, nNewReplayNodeIndex, false))         //Actually logging into logical node 1 as in replay mode
                    return M_ERROR;
            }

            return M_SUCCESS;
        }

        ////////////////////////////////////////////////////////////////////////////////
        // Function   : LoadRpConfig
        // Description: Creates a message for VCS which controls record/replay configuration
        //							(as appropriate).
        ////////////////////////////////////////////////////////////////////////////////
        //##ModelId=4119F5920247
        public bool LoadRpConfig(int VIC_ExNo)
        {
            QueuedMsg_t newMsg;
            ushort psData;
            RPConfiguration_t* pRPConfig;
            int n, i;
            char szTemp[50];

            if (WAIT_TIMEOUT == WaitForSingleObject(m_pVcsExManage[VIC_ExNo].hQueueMutex, 2000))
                return M_ERROR;

            /* I_EC_RP_CONFIG */
            if (!(newMsg = AddMessageToQueue(VIC_ExNo, F_RPCONF)))
            {
                ReleaseMutex(m_pVcsExManage[VIC_ExNo].hQueueMutex);
                return M_ERROR;
            }

            newMsg->MsgHeader.sID = (ushort)I_EC_RP_CONFIG;
            newMsg->MsgHeader.sReserved = 0;

            newMsg->sMsgExpectedReply = A_EC_RP_CONFIG;

            psData = (USHORT*)&newMsg->MsgData;

            *(psData++) = m_pVcsExManage[VIC_ExNo].sVcsExerciseNumber;


            *(psData++) = m_pVcsExManage[VIC_ExNo].sRPCount;
            pRPConfig = (RPConfiguration_t*)psData;

#if _VCS_INTERCHANGE_TRACE
		sprintf(m_szTrace, "New RP Config (%d nodes):-\n",m_pVcsExManage[VIC_ExNo].sRPCount );
		Console.WriteLine("");
#endif

            for (n = 0; n < m_pVcsExManage[VIC_ExNo].sRPCount; ++n)
            { /* convert physical node to logical node */
                i = 0;

                while ((m_pVcsExManage[VIC_ExNo].Roles[i].sPhysicalNode != m_pVcsExManage[VIC_ExNo].sRPNode[n]) &&
                             (i < m_pVcsExManage[VIC_ExNo].sRoleCount))
                    i++;

                if (i == m_pVcsExManage[VIC_ExNo].sRoleCount)
                {
                    ReleaseMutex(m_pVcsExManage[VIC_ExNo].hQueueMutex);
                    return M_ERROR;
                }

#if _VCS_INTERCHANGE_TRACE
			sprintf(m_szTrace, "	(%d) RecLN %d ", n, m_pVcsExManage[VIC_ExNo].Roles[i].sLogicalNode);
#endif

                pRPConfig->usRecordLogicalNode = m_pVcsExManage[VIC_ExNo].Roles[i].sLogicalNode;

                switch (m_pVcsExManage[VIC_ExNo].eLoadType)
                {
                    case EXERCISE_REPLAY:

                        pRPConfig++->usReplayLogicalNode = 1;
#if _VCS_INTERCHANGE_TRACE
					sprintf(szTemp, "RepLN 1\n");
					strcat(m_szTrace, szTemp);
					Console.WriteLine("");
#endif
                        break;

                    case EXERCISE_RECOVERY: // no longer utilised
                        pRPConfig++->usReplayLogicalNode = m_pVcsExManage[VIC_ExNo].Roles[i].sLogicalNode;
#if _VCS_INTERCHANGE_TRACE
					sprintf(szTemp, "RepLN %d\n",m_pVcsExManage[VIC_ExNo].Roles[i].sLogicalNode);
					strcat(m_szTrace, szTemp);
					Console.WriteLine("");
#endif
                        break;

                    default:
                        pRPConfig++->usReplayLogicalNode = 0;
#if _VCS_INTERCHANGE_TRACE
					sprintf(szTemp, "RepLN 0\n");
					strcat(m_szTrace, szTemp);
					Console.WriteLine("");
#endif
                        break;
                }
            }

            newMsg->MsgHeader.usLength = 4 + (m_pVcsExManage[VIC_ExNo].sRPCount * sizeof(RPConfiguration_t));
            newMsg->nMsgSize = newMsg->MsgHeader.usLength + sizeof(vcsHeader_t);
            m_pVcsExManage[VIC_ExNo].nMsgCnt++;

            /* Signal message ready to send */
            if (MESSAGE_IDLE == m_pVcsExManage[VIC_ExNo].eMsgStatus)
                m_pVcsExManage[VIC_ExNo].eMsgStatus = MESSAGE_READY;

            ReleaseMutex(m_pVcsExManage[VIC_ExNo].hQueueMutex);

            return M_SUCCESS;
        }

        ////////////////////////////////////////////////////////////////////////////////
        // Function   : LoginIlExercise
        // Description: Creates a message for VCS which logs a trainee desk into the IL
        //							session
        ////////////////////////////////////////////////////////////////////////////////
        //##ModelId=4119F5920189
        public bool LoginIlExercise(short sRoleIdx)
        {
            string newMsg;
            Login_t pLoginMsg;

            if (WAIT_TIMEOUT == WaitForSingleObject(m_pVcsExManage[IL_IDX].hQueueMutex, 2000))
                return M_ERROR;

            /* Message gets added to IL_IDX queue! */
            if (!(newMsg = AddMessageToQueue(IL_IDX, F_ILOGIN)))
            {
                ReleaseMutex(m_pVcsExManage[IL_IDX].hQueueMutex);
                return M_ERROR;
            }

            /* I_LOGIN */
            newMsg->MsgHeader.sID = (ushort)I_LOGIN;
            newMsg->MsgHeader.sReserved = 0;

            newMsg->sMsgExpectedReply = A_LOGIN;

            pLoginMsg = (Login_t) & newMsg->MsgData;

            pLoginMsg->sExerciseNumber = m_pVcsExManage[IL_IDX].sVcsExerciseNumber;

            memcpy((void)pLoginMsg->cRoleName,
                                (void)m_pVcsExManage[IL_IDX].Roles[sRoleIdx].szRoleName,
                                sizeof(m_pVcsExManage[IL_IDX].Roles[sRoleIdx].szRoleName));

            pLoginMsg->sLogicalNode = m_pVcsExManage[IL_IDX].Roles[sRoleIdx].sLogicalNode;

            newMsg->MsgHeader.usLength = sizeof(Login_t);
            newMsg->nMsgSize = newMsg->MsgHeader.usLength + sizeof(vcsHeader_t);
            m_pVcsExManage[IL_IDX].nMsgCnt++;

            /* Signal message ready to send */
            if (MESSAGE_IDLE == m_pVcsExManage[IL_IDX].eMsgStatus)
                m_pVcsExManage[IL_IDX].eMsgStatus = MESSAGE_READY;

            ReleaseMutex(m_pVcsExManage[IL_IDX].hQueueMutex);

            return M_SUCCESS;

        }

        ////////////////////////////////////////////////////////////////////////////////
        // Function   : LogoutIlExercise
        // Description: Creates a message for VCS which logs out trainee desk from the IL
        //							session
        ////////////////////////////////////////////////////////////////////////////////
        //##ModelId=4119F59201BB
        public bool LogoutIlExercise(short sRoleIdx)
        {
            QueuedMsg_t newMsg;
            Login_t pLoginMsg;

            if (WAIT_TIMEOUT == WaitForSingleObject(m_pVcsExManage[IL_IDX].hQueueMutex, 2000))
                return M_ERROR;

            if (!(newMsg = AddMessageToQueue(IL_IDX, F_LOGOUT)))
            {
                ReleaseMutex(m_pVcsExManage[IL_IDX].hQueueMutex);
                return M_ERROR;
            }

            /* I_LOGOUT */
            newMsg->MsgHeader.sID = (USHORT)I_LOGOUT;
            newMsg->MsgHeader.sReserved = 0;

            newMsg->sMsgExpectedReply = A_LOGOUT;

            pLoginMsg = (Login_t*)&newMsg->MsgData;

            pLoginMsg->sExerciseNumber = m_pVcsExManage[IL_IDX].sVcsExerciseNumber;

            memcpy((void*)pLoginMsg->cRoleName,
                                (void*)m_pVcsExManage[IL_IDX].Roles[sRoleIdx].szRoleName,
                                sizeof(m_pVcsExManage[IL_IDX].Roles[sRoleIdx].szRoleName));

            pLoginMsg->sLogicalNode = m_pVcsExManage[IL_IDX].Roles[sRoleIdx].sLogicalNode;

            newMsg->MsgHeader.usLength = sizeof(Login_t);
            newMsg->nMsgSize = newMsg->MsgHeader.usLength + sizeof(vcsHeader_t);
            m_pVcsExManage[IL_IDX].nMsgCnt++;

            /* Signal message ready to send */
            if (MESSAGE_IDLE == m_pVcsExManage[IL_IDX].eMsgStatus)
                m_pVcsExManage[IL_IDX].eMsgStatus = MESSAGE_READY;

            ReleaseMutex(m_pVcsExManage[IL_IDX].hQueueMutex);

            return M_SUCCESS;

        }

        ////////////////////////////////////////////////////////////////////////////////
        // Function   : SetImpositionControl
        // Description: Creates a message for VCS which controls instructor voice imposition
        ////////////////////////////////////////////////////////////////////////////////
        //##ModelId=4119F59203BA
        public bool SetImpositionControl(msgVCSImpositionControl_t pData)
        {
            string newMsg;
            ushort psData;

            short nn;

            if (WAIT_TIMEOUT == WaitForSingleObject(m_tVcsGenManage.hQueueMutex, 2000))
                return M_ERROR;

            if (pData->bImpositionState)
            {   /* Initiate Imposition */
                if (!(newMsg = AddMessageToQueue(NO_EXERCISE, F_LOADIMPOS)))
                {
                    ReleaseMutex(m_tVcsGenManage.hQueueMutex);
                    return M_ERROR;
                }

                newMsg->MsgHeader.sID = (USHORT)I_IMPOSE_START;
                newMsg->MsgHeader.sReserved = 0;

                newMsg->sMsgExpectedReply = A_IMPOSE_START;

                psData = (USHORT*)&newMsg->MsgData;

                (psData++) = (short)pData->nSupervisorPhysicalNode + m_sTotalNumTrainees + DESK_OFFSET;
                (psData++) = (short)pData->nNumberOfRecipients;
                for (nn = 0; nn < pData->nNumberOfRecipients; ++nn)
                {
                    sprintf(m_szTrace, "index  %d Node %d \n", nn, (short)pData->nRecipientPhysicalNode[nn] + DESK_OFFSET);
                    Console.WriteLine("");
                    (psData++) = (short)pData->nRecipientPhysicalNode[nn] + DESK_OFFSET;

                }

                newMsg->MsgHeader.usLength = 4 + (2 * pData->nNumberOfRecipients);
                newMsg->nMsgSize = newMsg->MsgHeader.usLength + sizeof(vcsHeader_t);
                m_tVcsGenManage.nMsgCnt++;
            }
            else
            {   /* End Imposition */
                if (!(newMsg = AddMessageToQueue(NO_EXERCISE, F_LOADIMPOS)))
                {
                    ReleaseMutex(m_tVcsGenManage.hQueueMutex);
                    return M_ERROR;
                }

                newMsg->MsgHeader.sID = (USHORT)I_IMPOSE_END;
                newMsg->MsgHeader.sReserved = 0;

                newMsg->sMsgExpectedReply = A_IMPOSE_END;

                psData = (USHORT*)&newMsg->MsgData;

                *(psData++) = (short)pData->nSupervisorPhysicalNode + m_sTotalNumTrainees + DESK_OFFSET;

                newMsg->MsgHeader.usLength = 2;
                newMsg->nMsgSize = newMsg->MsgHeader.usLength + sizeof(vcsHeader_t);
                m_tVcsGenManage.nMsgCnt++;
            }

            /* Signal message ready to send */
            if (MESSAGE_IDLE == m_tVcsGenManage.eMsgStatus)
                m_tVcsGenManage.eMsgStatus = MESSAGE_READY;

            ReleaseMutex(m_tVcsGenManage.hQueueMutex);

            return M_SUCCESS;
        }

        //////////////////////////////////////////////////////////////////////////////////
        //// Function   : SendSynchronisation
        //// Description: Creates and sends a message to control VCS Synchronisation
        //////////////////////////////////////////////////////////////////////////////////
        ////##ModelId=4119F593000E
        //public void SendSynchronisation(string pData)//msgSyncTime_T pData)
        //{
        //    QueuedMsg_t newMsg;
        //    char szData;
        //    int nTxdBytes;
        //	extern System.Net.Sockets.Socket clientSocket;

        //	/* Need to send this message immediately - no queueing */
        //	newMsg.MsgHeader.sID = (USHORT) I_TIME_DATE;
        //	newMsg.MsgHeader.sReserved = 0;

        //	/* Set time to format DD/MM/YYY HH:MM:SS:mmm */
        //	szData = newMsg.MsgData;


        //    strcpy(szData, "");
        //    //AppendIntStr(szData, pData->wDay, Pad_2);					//1 - 31
        //    AppendIntStr(szData, 1, Pad_2);					//Observation 1121 

        //    strcat(szData, "/");

        //    AppendIntStr(szData, pData->wMonth, Pad_2);				//1 - 12

        //    strcat(szData, "/");

        //    AppendIntStr(szData, pData->wYear, Pad_4);				//current year minus 1900

        //    strcat(szData, " ");


        //    AppendIntStr(szData, pData->wHour + 1, Pad_2);				//0 - 23 + 1 IS TEMP TEST

        //    strcat(szData, ":");

        //    AppendIntStr(szData, pData->wMinute, Pad_2);			//0 - 59

        //    strcat(szData, ":");

        //    AppendIntStr(szData, pData->wSecond, Pad_2);			//0 - 59

        //    strcat(szData, ":");

        //    AppendIntStr(szData, pData->wMilliseconds, Pad_3);

        //newMsg.MsgHeader.usLength = strlen(szData) + 1;	
        //	newMsg.nMsgSize = newMsg.MsgHeader.usLength + sizeof (vcsHeader_t);

        //	/* Send  Message */
        //	if (WAIT_TIMEOUT == WaitForSingleObject(m_tVcsIfManage.hTransmitMutex, 2000))
        //		return;

        //	if ((m_tVcsIfManage.eVCS_LinkState == READY_CONNECT) ||
        //			(m_tVcsIfManage.eVCS_LinkState == BUSY_CONNECT))
        //	{
        //		#if _VCS_SYNC_STATUS_TRACE
        //			sprintf(m_szTrace, GetVCSError(newMsg.MsgHeader.sID, NO_EXERCISE, eTX));
        //			Console.WriteLine("");
        //		#endif

        //		#if _VCS_RAW_INTERCHANGE
        //			TRACE("Message Sent %d\n", I_TIME_DATE);
        //		#endif

        //		nTxdBytes = send(clientSocket, (char) &newMsg.MsgHeader, newMsg.nMsgSize, 0);

        //		/* Check for successful send */ 
        //		if (nTxdBytes< 0)
        //		{		
        //			m_nErrorCode = GetWSAError(WSAGetLastError ());

        //            SendLoggerMessage(T_AMS_EXM, NO_EXERCISE, "Failure to send synchronisation message");
        //		}
        //	}


        //    ReleaseMutex(m_tVcsIfManage.hTransmitMutex);

        //	return;
        //}

        ////////////////////////////////////////////////////////////////////////////////
        // Function   : SendShutdownRequest
        // Description: Creates and sends a message to request VCS shutdown
        ////////////////////////////////////////////////////////////////////////////////
        //##ModelId=4119F593004A
        public void SendShutdownRequest()
        {
            //        QueuedMsg_t newMsg;
            //        int nTxdBytes;

            //extern System.Net.Sockets.Socket clientSocket;


            /* Need to send this message immediately - no queueing */
            //       newMsg.MsgHeader.sID = (ushort)I_SC_SHUTDOWN;
            //newMsg.MsgHeader.sReserved = 0;
            //newMsg.MsgHeader.usLength = 0;


            //newMsg.nMsgSize = sizeof (vcsHeader_t);

            ///* Send  Message */
            //if (WAIT_TIMEOUT == WaitForSingleObject(m_tVcsIfManage.hTransmitMutex, 2000))
            //	return;

            //if ((READY_CONNECT == m_tVcsIfManage.eVCS_LinkState) ||
            //		(BUSY_CONNECT == m_tVcsIfManage.eVCS_LinkState))
            //{
            //	#if _VCS_INTERCHANGE_TRACE
            //		sprintf(m_szTrace, GetVCSError(newMsg.MsgHeader.sID, NO_EXERCISE, eTX));
            //		Console.WriteLine("");
            //	#endif

            //	#if _VCS_RAW_INTERCHANGE
            //		TRACE("Message Sent %d\n", I_SC_SHUTDOWN);
            //	#endif

            //	nTxdBytes = send(clientSocket, (char*) &newMsg.MsgHeader, newMsg.nMsgSize, 0);

            //	/* Check for successful send */
            //	if (nTxdBytes< 0)
            //	{		
            //		m_nErrorCode = GetWSAError(WSAGetLastError ());

            //           SendLoggerMessage(T_AMS_EXM, NO_EXERCISE, "Failure to shutdown VCS system");
            //	}	
            //}


            //   ReleaseMutex(m_tVcsIfManage.hTransmitMutex);

            return;
        }

        ////////////////////////////////////////////////////////////////////////////////
        // Function   : SendStatus Request
        // Description: Creates a message to request VCS status
        ////////////////////////////////////////////////////////////////////////////////
        //##ModelId=4119F5930068
        public void SendStatusRequest()
        {
            System.Net.Sockets.Socket clientSocket;

            /* Need to send this message immediately - no queueing */
            if (WAIT_TIMEOUT == WaitForSingleObject(m_tVcsIfManage.hTransmitMutex, 2000))
                return;

            if ((m_tVcsIfManage.eVCS_LinkState == READY_CONNECT) ||
                    (m_tVcsIfManage.eVCS_LinkState == BUSY_CONNECT))
            {
#if _VCS_SYNC_STATUS_TRACE
			sprintf(m_szTrace, GetVCSError(m_tVcsIfManage.msgRU_ALIVE.MsgHeader.sID, NO_EXERCISE, eTX));
			Console.WriteLine("");
#endif

#if _VCS_RAW_INTERCHANGE
			TRACE("Message Sent %d\n", m_tVcsIfManage.msgRU_ALIVE.MsgHeader.sID);
#endif


                nTxdBytes = send(clientSocket, (char*)&m_tVcsIfManage.msgRU_ALIVE.MsgHeader, m_tVcsIfManage.msgRU_ALIVE.nMsgSize, 0);
                /* Check for successful send */
                if (nTxdBytes < 0)
                {
                    m_nErrorCode = GetWSAError(WSAGetLastError());

                    SendLoggerMessage(T_AMS_EXM, NO_EXERCISE, "Failure to send synchronisation message");
                }
            }


            ReleaseMutex(m_tVcsIfManage.hTransmitMutex);

            return;
        }

        ////////////////////////////////////////////////////////////////////////////////
        // Function   : ClearVcsExercise
        // Description: Clears exercise configuration data from the exercise management 
        //							structure.  Also deletes all messages queued for this exercise.
        ////////////////////////////////////////////////////////////////////////////////
        //##ModelId=4119F59202C9
        public void ClearVcsExercise(int VIC_ExNo)
        {
            int n;
            QueuedMsg_t pNextQueuedMsg;

            if (NO_EXERCISE == VIC_ExNo)
            {
                while (m_tVcsGenManage.pMsgQueue)
                {   /* Free unsent messages */
                    pNextQueuedMsg = m_tVcsGenManage.pMsgQueue->pNextMsg;
                    free(m_tVcsGenManage.pMsgQueue);
                    m_tVcsGenManage.pMsgQueue = pNextQueuedMsg;
                }

                m_tVcsGenManage.nMsgCnt = 0;
                m_tVcsGenManage.eMsgStatus = MESSAGE_IDLE;
                m_tVcsGenManage.bStopAllExerciseProcessing = 0;
            }
            else
            {
                /* Update node status before clearing out data (except if running IL exercise) */
                if ((m_pVcsExManage[VIC_ExNo].eED_State != ED_UNDEFINED) &&
                        (strcmp(m_pVcsExManage[VIC_ExNo].szExerciseMode, "IL")))
                    UpdateExerciseStatus(VIC_ExNo, CScenarioComponent::UNINITIALISED);

                /* Miscellaneous enumerations */
                m_pVcsExManage[VIC_ExNo].eEC_State = EC_NULL;
                m_pVcsExManage[VIC_ExNo].eED_State = ED_UNDEFINED;
                m_pVcsExManage[VIC_ExNo].eLoadType = EXERCISE_NULL;
                m_pVcsExManage[VIC_ExNo].bRestart = false;
                m_pVcsExManage[VIC_ExNo].cScenarioState = (byte)CScenarioComponent::NON_OPERATIONAL;

                /* Clear out fixed sized strings */
                for (n = 0; n < 25; n++)
                {
                    m_pVcsExManage[VIC_ExNo].szExerciseSpecificationName[n] = 0;
                    m_pVcsExManage[VIC_ExNo].szUniqueExerciseName[n] = 0;
                    m_pVcsExManage[VIC_ExNo].szRecordFileName[n] = 0;
                    m_pVcsExManage[VIC_ExNo].szLogFileName[n] = 0;
                }

                for (; n < 128; n++)
                {
                    m_pVcsExManage[VIC_ExNo].szRecordFileName[n] = 0;
                    m_pVcsExManage[VIC_ExNo].szLogFileName[n] = 0;
                }

                sprintf(m_pVcsExManage[VIC_ExNo].szRecordFileIndex, "0");
                memset(m_pVcsExManage[VIC_ExNo].szExerciseMode, 0, sizeof(m_pVcsExManage[VIC_ExNo].szExerciseMode));

                /* Miscellaneous flags */
                m_pVcsExManage[VIC_ExNo].bStopAllExerciseProcessing = false;

                /* Trainee Monitoring */
                for (n = 0; n < m_sTotalNumInstructors; n++)
                {
                    m_pVcsExManage[VIC_ExNo].bMonitorActiveSupervisor[n] = false;
                    m_pVcsExManage[VIC_ExNo].sMonitorActiveTrainee[n] = 0;
                }

                /* Timestamps */
                m_pVcsExManage[VIC_ExNo].dScenarioTime = 0.0;
                m_pVcsExManage[VIC_ExNo].dExerciseTime = 0.0;
                m_pVcsExManage[VIC_ExNo].nTickMultiplier = 1;

                /* Clear message queue */
                ClearMsgQueue(VIC_ExNo);
                m_pVcsExManage[VIC_ExNo].bStoppingExercise = false;

                /* Record/Replay Configuration */
                m_pVcsExManage[VIC_ExNo].sRPCount = 0;
                m_pVcsExManage[VIC_ExNo].sRPCountPrevious = 0;
                m_pVcsExManage[VIC_ExNo].sRPPreviousValid = false;
                m_pVcsExManage[VIC_ExNo].sShortTermRecordControl = 0;
                m_pVcsExManage[VIC_ExNo].sLongTermRecordControl = 0;

                for (n = 0; n < m_sTotalNumNodes; n++)
                {
                    m_pVcsExManage[VIC_ExNo].sRPNode[n] = 0;
                    m_pVcsExManage[VIC_ExNo].sRPNodePrevious[n] = 0;
                }

                /* Exercise configuration */
                m_pVcsExManage[VIC_ExNo].sVcsExerciseNumber = NO_EXERCISE;

                m_pVcsExManage[VIC_ExNo].sActorCount = 0;
                m_pVcsExManage[VIC_ExNo].sRoleCount = 0;
                m_pVcsExManage[VIC_ExNo].sRadioCount = 0;

                for (n = 0; n < m_sTotalNumNodes; n++)
                {
                    m_pVcsExManage[VIC_ExNo].Roles[n].eLoginStatus = LOGIN_NOT;
                    m_pVcsExManage[VIC_ExNo].Roles[n].nAssignedActors = 0;
                    m_pVcsExManage[VIC_ExNo].Roles[n].nAssignedRadios = 0;
                    m_pVcsExManage[VIC_ExNo].Roles[n].sLogicalNode = 0;
                    m_pVcsExManage[VIC_ExNo].Roles[n].sPhysicalNode = 0;
                    m_pVcsExManage[VIC_ExNo].Roles[n].sRoleID = 0;
                    m_pVcsExManage[VIC_ExNo].Roles[n].sRoleType = 0;
                    m_pVcsExManage[VIC_ExNo].Roles[n].sSide = eBLUE;
                    memset(m_pVcsExManage[VIC_ExNo].Roles[n].szPlatform, 0, sizeof(m_pVcsExManage[VIC_ExNo].Roles[n].szPlatform));
                memset(m_pVcsExManage[VIC_ExNo].Roles[n].szRoleName, 0, sizeof(m_pVcsExManage[VIC_ExNo].Roles[n].szRoleName));
            }

            //          for (n = 0; n < m_sTotalNumRadios; n++)
            //          {
            //              //m_pVcsExManage[VIC_ExNo].Radio[n].sRadioID = 0;
            //              m_pVcsExManage[VIC_ExNo].Radio[n].sType = eHF;
            //              memset(m_pVcsExManage[VIC_ExNo].Radio[n].szFrequency, 0, sizeof(m_pVcsExManage[VIC_ExNo].Radio[n].szFrequency));
            //              memset(m_pVcsExManage[VIC_ExNo].Radio[n].szStation, 0, sizeof(m_pVcsExManage[VIC_ExNo].Radio[n].szStation));
            //              m_pVcsExManage[VIC_ExNo].Radio[n].sKeyNumber = 0;


            //          for (n=0; n<m_sTotalNumActors; n++)
            //   	{

            //            memset(m_pVcsExManage[VIC_ExNo].Actor[n].szPlatform, 0, sizeof(m_pVcsExManage[VIC_ExNo].Actor[n].szPlatform));	 

            //            memset(m_pVcsExManage[VIC_ExNo].Actor[n].szRoleName, 0, sizeof(m_pVcsExManage[VIC_ExNo].Actor[n].szRoleName));
            //	  m_pVcsExManage[VIC_ExNo].Actor[n].sKeyNumber = 0;
            //   	}

            //   	/* Connectivity - clear out connectivity arrays */
            //   	for (n=0; n<m_sTotalNumDesks; n++)
            //    { 
            //	m_pVcsExManage[VIC_ExNo].RefConnectivity[n].ownPlatformHFMast =		eMASK_NONE;
            //	m_pVcsExManage[VIC_ExNo].RefConnectivity[n].ownPlatformUHFMast =	eMASK_NONE;
            //	for (i=0; i<NO_OF_COMMS_VEHICLES; ++i)
            //	{
            //		m_pVcsExManage[VIC_ExNo].RefConnectivity[n].friendlyVehicles[i] = -1;
            //		m_pVcsExManage[VIC_ExNo].RefConnectivity[n].availableUHFComms[i] =	eMASK_NONE;
            //		m_pVcsExManage[VIC_ExNo].RefConnectivity[n].availableHFComms[i] =		eMASK_NONE;
            //	}
            //}	


            return;
        }

        ////////////////////////////////////////////////////////////////////////////////
        // Function   : SetTraineeConnectivity
        // Description: Determines the two trainees associated with a trainee vehicle then for 
        //							each radio channel received by each trainee creates a connectivity 
        //							message defining what transmitters (comms nodes) are 'connected'
        ////////////////////////////////////////////////////////////////////////////////
        //##ModelId=4119F59202FB
    //    public bool SetTraineeConnectivity(int VIC_ExNo, long lParentDesk, RefConnectivity_t pCon)
    //    {
            //    QueuedMsg_t newMsg;
            //    ushort psData;
            //    ushort pNoElements;
            //    ReceptionMap_t pRecnMap;
            //    char pcData;
            //    int nReceiverCnt, nReceiverPhysicalNode, nReceiverNodeRoleID;
            //    int nRoleIdx, nRadioIdx;
            //    int nDeskCnt, nThisRoleDeskNo;

            //#if _VIC_CONNECTIVITY_TRACE
            //		char	szLocal1[500];
            //		char	szLocal2[30];
            //		char  *pcTemp;
            //#endif

            //    if (WAIT_TIMEOUT == WaitForSingleObject(m_pVcsExManage[VIC_ExNo].hQueueMutex, 2000))
            //        return M_ERROR;

            //    /* Update reference data */
            //    memcpy(&m_pVcsExManage[VIC_ExNo].RefConnectivity[lParentDesk - 1],
            //                 pCon,
            //                 sizeof(RefConnectivity_t));

            //    /* 	Vehicle from Vehicle and Vehicle from Instructor Connectivity */
            //    for (nReceiverCnt = 0; nReceiverCnt < 2; ++nReceiverCnt)
            //    {
            //        /* Convert from desk to physical node */
            //        nReceiverPhysicalNode = (lParentDesk * 2) - nReceiverCnt + DESK_OFFSET;

            //        /* Find trainee role at this physical node */
            //        for (nReceiverNodeRoleID = 0; nReceiverNodeRoleID < m_pVcsExManage[VIC_ExNo].sRoleCount; ++nReceiverNodeRoleID)
            //        {
            //            if ((m_pVcsExManage[VIC_ExNo].Roles[nReceiverNodeRoleID].sPhysicalNode == nReceiverPhysicalNode) &&
            //                    (CSystemComponent::SPARK_TRAINEE_OPERATOR == m_pVcsExManage[VIC_ExNo].Roles[nReceiverNodeRoleID].sRoleType))
            //                break;
            //        }

            //        if (nReceiverNodeRoleID == m_pVcsExManage[VIC_ExNo].sRoleCount)
            //        {
            //            ReleaseMutex(m_pVcsExManage[VIC_ExNo].hQueueMutex);
            //            return M_ERROR;
            //        }

            //        /* Need to send connectivity message for each radio channel used by this node */
            //        for (nRadioIdx = 0; nRadioIdx < m_sTotalNumRadios; ++nRadioIdx)
            //        {
            //            if ((m_pVcsExManage[VIC_ExNo].Roles[nReceiverNodeRoleID].nAssignedRadios >> nRadioIdx) & 1)
            //            {
            //                /* I_CONNECTIVITY */
            //                if (!(newMsg = AddMessageToQueue(VIC_ExNo, F_CONNECT)))
            //                {
            //                    ReleaseMutex(m_pVcsExManage[VIC_ExNo].hQueueMutex);
            //                    return M_ERROR;
            //                }

            //                newMsg->MsgHeader.sID = (ushort)I_CONNECTIVITY;
            //                newMsg->MsgHeader.sReserved = 0;

            //                newMsg->sMsgExpectedReply = A_NONE;

            //                psData = (ushort*)&newMsg->MsgData;

            //                psData++ = m_pVcsExManage[VIC_ExNo].sVcsExerciseNumber;
            //                psData++ = m_pVcsExManage[VIC_ExNo].Roles[nReceiverNodeRoleID].sLogicalNode;

            //                pcData = (char)psData;

            //                memcpy((void)pcData,
            //                                (void)m_pVcsExManage[VIC_ExNo].Radio[nRadioIdx].szFrequency,
            //                                sizeof(m_pVcsExManage[VIC_ExNo].Radio[nRadioIdx].szFrequency));

            //    pcData += sizeof(m_pVcsExManage[VIC_ExNo].Radio[nRadioIdx].szFrequency);

            //    memcpy((void)pcData,
            //                    (void*)m_pVcsExManage[VIC_ExNo].Radio[nRadioIdx].szStation,
            //                    sizeof(m_pVcsExManage[VIC_ExNo].Radio[nRadioIdx].szStation) );

            //    pcData += sizeof(m_pVcsExManage[VIC_ExNo].Radio[nRadioIdx].szStation);

            //#if _VIC_CONNECTIVITY_TRACE
            //					memset((void*) szLocal1, 0, sizeof(szLocal1));

            //					sprintf(szLocal1, "VCS trainee connectivity for %d ", m_pVcsExManage[VIC_ExNo].Roles[nReceiverNodeRoleID].sPhysicalNode);			

            //					pcTemp = (char*) &szLocal1[strlen(szLocal1)];

            //					memcpy(	(void*)pcTemp, 
            //									(void*)m_pVcsExManage[VIC_ExNo].Radio[nRadioIdx].szFrequency,
            //									sizeof(m_pVcsExManage[VIC_ExNo].Radio[nRadioIdx].szFrequency));

            //					strcat(szLocal1, szSpace);
            //					pcTemp = (char*) &szLocal1[strlen(szLocal1)];

            //					memcpy(	(void*)pcTemp, 
            //									(void*)m_pVcsExManage[VIC_ExNo].Radio[nRadioIdx].szStation,
            //									sizeof(m_pVcsExManage[VIC_ExNo].Radio[nRadioIdx].szStation));

            //					strcat(szLocal1, szSpace);				
            //#endif

            //    pNoElements = (ushort)pcData;
            //    pRecnMap = (ReceptionMap_t)(pNoElements + 1);

            //    pNoElements = 0;

            //    newMsg->MsgHeader.usLength = 6 +
            //                                                                sizeof(m_pVcsExManage[VIC_ExNo].Radio[nRadioIdx].szStation) +
            //                                                                sizeof(m_pVcsExManage[VIC_ExNo].Radio[nRadioIdx].szFrequency);

            //    /* Find other roles using this radio channel */
            //    for (nRoleIdx = 0; nRoleIdx < m_pVcsExManage[VIC_ExNo].sRoleCount; ++nRoleIdx)
            //    {
            //        if (nRoleIdx == nReceiverNodeRoleID)
            //            continue;

            //        switch (m_pVcsExManage[VIC_ExNo].Roles[nRoleIdx].sRoleType)
            //        {
            //            case CSystemComponent::SPARK_INSTRUCTOR:
            //                if ((m_pVcsExManage[VIC_ExNo].Roles[nRoleIdx].nAssignedRadios >> nRadioIdx) & 1)
            //                {   /* Instructor role using parent trainee radio channel - can only mask due to parent vehicle mast state  */
            //                    pRecnMap->usLogicalNodeNo = m_pVcsExManage[VIC_ExNo].Roles[nRoleIdx].sLogicalNode;
            //                    pRecnMap->usPercentageReception = 100;

            //                    switch (m_pVcsExManage[VIC_ExNo].Radio[nRadioIdx].sType)
            //                    {
            //                        case eUHF:
            //                            if (eMASK_MAST == pCon->ownPlatformUHFMast)
            //                                pRecnMap->usPercentageReception = 0;
            //                            break;
            //                        case eHF:
            //                            if (eMASK_MAST == pCon->ownPlatformHFMast)
            //                                pRecnMap->usPercentageReception = 0;
            //                            break;
            //                    }

            //#if _VIC_CONNECTIVITY_TRACE
            //									sprintf(szLocal2, "[%d, %d%%] ", m_pVcsExManage[VIC_ExNo].Roles[nRoleIdx].sPhysicalNode, pRecnMap->usPercentageReception);
            //									strcat(szLocal1, szLocal2);
            //#endif

            //                    (pNoElements)++;
            //                    pRecnMap++;
            //                }
            //                break;

            //            case CSystemComponent::SPARK_TRAINEE_OPERATOR:
            //                if ((m_pVcsExManage[VIC_ExNo].Roles[nRoleIdx].nAssignedRadios >> nRadioIdx) & 1)
            //                {
            //                    /* Another trainee role using parent trainee radio channel - can mask due to mast and/or terrain state */
            //                    /* Set up 100% connectivity for roles at trainees sharing same desk */
            //                    pRecnMap->usLogicalNodeNo = m_pVcsExManage[VIC_ExNo].Roles[nRoleIdx].sLogicalNode;
            //                    pRecnMap->usPercentageReception = 100;

            //                    /* Only need to change connectivity if trainee vehicle not at same desk as parent vehicle */
            //                    nThisRoleDeskNo = (m_pVcsExManage[VIC_ExNo].Roles[nRoleIdx].sPhysicalNode + 1 - DESK_OFFSET) / 2;

            //                    if (lParentDesk != nThisRoleDeskNo)
            //                    {
            //                        /* This trainee is not sharing same desk so need to interrogate connectivity matrix  */
            //                        /* Connectivity level remains at 100% for vehicles not listed in connectivity matrix */
            //                        for (nDeskCnt = 0; nDeskCnt < NO_OF_COMMS_VEHICLES; ++nDeskCnt)
            //                        {
            //                            if (pCon->friendlyVehicles[nDeskCnt] == m_pVcsExManage[VIC_ExNo].Roles[nRoleIdx].nVehicleID)
            //                            {
            //                                switch (m_pVcsExManage[VIC_ExNo].Radio[nRadioIdx].sType)
            //                                {
            //                                    case eUHF:  //Terrain and mast masking
            //                                        if (eMASK_NONE != pCon->availableUHFComms[nDeskCnt])
            //                                            pRecnMap->usPercentageReception = 0;
            //                                        break;
            //                                    case eHF:       //Mast masking only
            //                                        if (eMASK_MAST == pCon->availableHFComms[nDeskCnt])
            //                                            pRecnMap->usPercentageReception = 0;
            //                                        break;
            //                                }
            //                                break;
            //                            }
            //                        }
            //                    }

            //#if _VIC_CONNECTIVITY_TRACE
            //									sprintf(szLocal2, "[%d, %d%%] ", m_pVcsExManage[VIC_ExNo].Roles[nRoleIdx].sPhysicalNode, pRecnMap->usPercentageReception);
            //									strcat(szLocal1, szLocal2);
            //#endif

            //                    (*pNoElements)++;
            //                    pRecnMap++;
            //                }
            //                break;

            //            //case eACTOR:
            //            default:
            //                /* Does not have radio assigned */
            //                break;
            //        }
            //    }
            //    newMsg->MsgHeader.usLength += *pNoElements * sizeof(ReceptionMap_t);
            //    newMsg->nMsgSize = newMsg->MsgHeader.usLength + sizeof(vcsHeader_t);
            //    m_pVcsExManage[VIC_ExNo].nMsgCnt++;

            //#if _VIC_CONNECTIVITY_TRACE
            //					strcat(szLocal1, "\n");
            //					Console.WriteLine(szLocal1);
            //#endif
            //}
            //		}
            //	}
            //	/* Signal message ready to send */		
            //	if (MESSAGE_IDLE == m_pVcsExManage[VIC_ExNo].eMsgStatus)
            //		m_pVcsExManage[VIC_ExNo].eMsgStatus = MESSAGE_READY;


            //    ReleaseMutex(m_pVcsExManage[VIC_ExNo].hQueueMutex);

       //     return M_SUCCESS;
       // }


        //////////////////////////////////////////////////////////////////////////////////
        //// Function   : SetInstructorConnectivity
        //// Description: Determines what trainee vehicle radio channels are connected to the
        ////							instructors.  The instructor radio channel connectivity is modified 
        ////							every time a trainee vehicle changes mast state. 
        //////////////////////////////////////////////////////////////////////////////////
        ////##ModelId=4119F5920356
        //public bool SetInstructorConnectivity(int VIC_ExNo, eRadioBand eBand, long lParentDesk, MaskState_E eMastState)
        //{
        //    QueuedMsg_t newMsg;
        //    ushort psData;
        //    ushort pNoElements;
        //    ReceptionMap_t pRecnMap;
        //    char pcData;
        //    int nReceiverNodeRoleID;
        //    int nRadioIdx;
        //    int nRoleIdx;
        //    int nThisRoleDeskNo;

        //#if _VIC_CONNECTIVITY_TRACE
        //		char	szLocal1[500];
        //		char	szLocal2[30];
        //		char  *pcTemp;
        //#endif

        //    if (WAIT_TIMEOUT == WaitForSingleObject(m_pVcsExManage[VIC_ExNo].hQueueMutex, 2000))
        //        return M_ERROR;

        //    /* Update reference data */
        //    switch (eBand)
        //    {
        //        case eHF:
        //            m_pVcsExManage[VIC_ExNo].RefConnectivity[lParentDesk - 1].ownPlatformHFMast = eMastState;
        //            break;

        //        case eUHF:
        //            m_pVcsExManage[VIC_ExNo].RefConnectivity[lParentDesk - 1].ownPlatformUHFMast = eMastState;
        //            break;
        //    }

        //    /* 	Instructor from Vehicle and Instructor from Instructor Connectivity */
        //    for (nReceiverNodeRoleID = 0; nReceiverNodeRoleID < m_sTotalNumInstructors; ++nReceiverNodeRoleID)
        //    {
        //        /* Need to send connectivity message for each radio channel used by this desk */
        //        for (nRadioIdx = 0; nRadioIdx < m_sTotalNumRadios; ++nRadioIdx)
        //        {
        //            if ((m_pVcsExManage[VIC_ExNo].Roles[nReceiverNodeRoleID].nAssignedRadios >> nRadioIdx) & 1)
        //            {
        //                if (m_pVcsExManage[VIC_ExNo].Radio[nRadioIdx].sType == eBand)
        //                {
        //                    /* I_CONNECTIVITY */
        //                    if (!(newMsg = AddMessageToQueue(VIC_ExNo, F_CONNECT)))
        //                    {
        //                        ReleaseMutex(m_pVcsExManage[VIC_ExNo].hQueueMutex);
        //                        return M_ERROR;
        //                    }

        //                    newMsg->MsgHeader.sID = (USHORT)I_CONNECTIVITY;
        //                    newMsg->MsgHeader.sReserved = 0;

        //                    newMsg->sMsgExpectedReply = A_NONE;

        //                    psData = (USHORT*)&newMsg->MsgData;

        //                    psData++ = m_pVcsExManage[VIC_ExNo].sVcsExerciseNumber;
        //                    psData++ = m_pVcsExManage[VIC_ExNo].Roles[nReceiverNodeRoleID].sLogicalNode;

        //                    pcData = (char)psData;

        //                    memcpy((void)pcData,
        //                                    (void)m_pVcsExManage[VIC_ExNo].Radio[nRadioIdx].szFrequency,
        //                                    sizeof(m_pVcsExManage[VIC_ExNo].Radio[nRadioIdx].szFrequency));

        //    pcData += sizeof(m_pVcsExManage[VIC_ExNo].Radio[nRadioIdx].szFrequency);

        //    memcpy((void)pcData,
        //                    (void*)m_pVcsExManage[VIC_ExNo].Radio[nRadioIdx].szStation,
        //                    sizeof(m_pVcsExManage[VIC_ExNo].Radio[nRadioIdx].szStation) );

        //    pcData += sizeof(m_pVcsExManage[VIC_ExNo].Radio[nRadioIdx].szStation);

        //#if _VIC_CONNECTIVITY_TRACE
        //						memset((void*) szLocal1, 0, sizeof(szLocal1));

        //						sprintf(szLocal1, "VCS instructor connectivity for %d ", m_pVcsExManage[VIC_ExNo].Roles[nReceiverNodeRoleID].sPhysicalNode);			

        //						pcTemp = (char*) &szLocal1[strlen(szLocal1)];

        //						memcpy(	(void*)pcTemp, 
        //										(void*)m_pVcsExManage[VIC_ExNo].Radio[nRadioIdx].szStation,
        //										sizeof(m_pVcsExManage[VIC_ExNo].Radio[nRadioIdx].szStation));

        //						strcat(szLocal1, szSpace);
        //						pcTemp = (char*) &szLocal1[strlen(szLocal1)];

        //						memcpy(	(void*)pcTemp, 
        //										(void*)m_pVcsExManage[VIC_ExNo].Radio[nRadioIdx].szFrequency,
        //										sizeof(m_pVcsExManage[VIC_ExNo].Radio[nRadioIdx].szFrequency));

        //						strcat(szLocal1, szSpace);
        //#endif

        //    pNoElements = (USHORT*)pcData;
        //    pRecnMap = (ReceptionMap_t*)(pNoElements + 1);

        //    *pNoElements = 0;

        //    newMsg->MsgHeader.usLength = 6 +
        //                                                                sizeof(m_pVcsExManage[VIC_ExNo].Radio[nRadioIdx].szStation) +
        //                                                                sizeof(m_pVcsExManage[VIC_ExNo].Radio[nRadioIdx].szFrequency);

        //    /* Find other roles using this radio channel */
        //    for (nRoleIdx = 0; nRoleIdx < m_pVcsExManage[VIC_ExNo].sRoleCount; ++nRoleIdx)
        //    {
        //        if (nRoleIdx == nReceiverNodeRoleID)
        //            continue;

        //        switch (m_pVcsExManage[VIC_ExNo].Roles[nRoleIdx].sRoleType)
        //        {
        //            case CSystemComponent::SPARK_INSTRUCTOR:
        //                if ((m_pVcsExManage[VIC_ExNo].Roles[nRoleIdx].nAssignedRadios >> nRadioIdx) & 1)
        //                {   /* No masking between instructors */
        //                    pRecnMap->usLogicalNodeNo = m_pVcsExManage[VIC_ExNo].Roles[nRoleIdx].sLogicalNode;
        //                    pRecnMap->usPercentageReception = 100;
        //                    (*pNoElements)++;

        //#if _VIC_CONNECTIVITY_TRACE
        //										sprintf(szLocal2, "[%d, %d%%] ", m_pVcsExManage[VIC_ExNo].Roles[nRoleIdx].sPhysicalNode, pRecnMap->usPercentageReception);
        //										strcat(szLocal1, szLocal2);
        //#endif

        //                    pRecnMap++;
        //                }
        //                break;

        //            case CSystemComponent::SPARK_TRAINEE_OPERATOR:
        //                if ((m_pVcsExManage[VIC_ExNo].Roles[nRoleIdx].nAssignedRadios >> nRadioIdx) & 1)
        //                {
        //                    /* Masking  defined by mast state */
        //                    pRecnMap->usLogicalNodeNo = m_pVcsExManage[VIC_ExNo].Roles[nRoleIdx].sLogicalNode;
        //                    pRecnMap->usPercentageReception = 100;

        //                    /* Find desk used by this role */
        //                    nThisRoleDeskNo = (m_pVcsExManage[VIC_ExNo].Roles[nRoleIdx].sPhysicalNode + 1 - DESK_OFFSET) / 2;

        //                    switch (eBand)
        //                    {
        //                        case eHF:
        //                            if (eMASK_MAST == m_pVcsExManage[VIC_ExNo].RefConnectivity[nThisRoleDeskNo - 1].ownPlatformHFMast)
        //                                pRecnMap->usPercentageReception = 0;
        //                            break;

        //                        case eUHF:
        //                            if (eMASK_MAST == m_pVcsExManage[VIC_ExNo].RefConnectivity[nThisRoleDeskNo - 1].ownPlatformUHFMast)
        //                                pRecnMap->usPercentageReception = 0; ;
        //                            break;
        //                    }

        //#if _VIC_CONNECTIVITY_TRACE
        //										sprintf(szLocal2, "[%d, %d%%] ", m_pVcsExManage[VIC_ExNo].Roles[nRoleIdx].sPhysicalNode, pRecnMap->usPercentageReception);
        //										strcat(szLocal1, szLocal2);
        //#endif

        //                    (*pNoElements)++;
        //                    pRecnMap++;
        //                }
        //                break;

        //            //case eACTOR:
        //            default:
        //                /* Does not have radio assigned */
        //                break;
        //        }
        //    }
        //    newMsg->MsgHeader.usLength += *pNoElements * sizeof(ReceptionMap_t);
        //    newMsg->nMsgSize = newMsg->MsgHeader.usLength + sizeof(vcsHeader_t);
        //    m_pVcsExManage[VIC_ExNo].nMsgCnt++;

        //#if _VIC_CONNECTIVITY_TRACE
        //						strcat(szLocal1, "\n");
        //						Console.WriteLine(szLocal1);
        //#endif
        //}
        //			}				
        //		}
        //	}

        //	/* Signal message ready to send */		
        //	if (MESSAGE_IDLE == m_pVcsExManage[VIC_ExNo].eMsgStatus)
        //		m_pVcsExManage[VIC_ExNo].eMsgStatus = MESSAGE_READY;


        //    ReleaseMutex(m_pVcsExManage[VIC_ExNo].hQueueMutex);

        //	return M_SUCCESS;
        //}


    }
}
